yy<- kmeans(as.matrix(rnorm(40, 22)), centers = 100)
yy$betweenss/yy$tot.withinss
yy<- kmeans(as.matrix(rnorm(40, 22)), centers = 10)
yy$betweenss/yy$tot.withinss
s.matrix(rnorm(40, 22)
as.matrix(rnorm(40, 22))
rnorm(40, 22)
source('~/MIT/Research/Autotuner/R/checkEICFunctions.R', echo=TRUE)
source('~/MIT/Research/Autotuner/R/checkEICPeaks.R', echo=TRUE)
source('~/MIT/Research/Autotuner/R/EICParams.R', echo=TRUE)
roxygen2::roxygenise()
library(Autotuner)
source('~/MIT/Research/Autotuner/R/EICParams.R', echo=TRUE)
library(Autotuner)
library(Autotuner)
library(Autotuner)
dataPaths
source('~/MIT/Research/xcmsAutotuner/scr/2019-03-25/casero_param_test.R', echo=TRUE)
library(Autotuner)
usethis::use_package("entropy")
roxygen2::roxygenise()
library(Autotuner)
library(Autotuner)
library(Autotuner)
library(Autotuner)
library(Autotuner)
library(Autotuner)
library(Autotuner)
library(Autotuner)
library(Autotuner)
library(Autotuner)
library(Autotuner)
library(Autotuner)
library(Autotuner)
library(Autotuner)
library(Autotuner)
source('~/MIT/Research/Autotuner/R/EICParams.R', echo=TRUE)
library(Autotuner)
library(Autotuner)
library(Autotuner)
library(Autotuner)
library(Autotuner)
library(Autotuner)
source('~/MIT/Research/Autotuner/R/checkEICFunctions.R', echo=TRUE)
library(Autotuner)
?sample
sample( 5000)
library(Autotuner)
sample(x = 1:length(ppmObs), n = 5000)
library(Autotuner)
library(Autotuner)
library(Autotuner)
launchAutotuner()
library(Autotuner)
library(Autotuner)
library(Autotuner)
Autotuner::findTruePeaks
Autotuner::findTruePeaks
library(Autotuner)
library(Autotuner)
library(Autotuner)
library(Autotuner)
library(Autotuner)
library(Autotuner)
roxygen2::roxygenise()
source('~/MIT/Research/Autotuner/R/checkEICFunctions.R', echo=TRUE)
usethis::use_package("cluster")
devtools::use_mit_license()
usethis::use_mit_license()
usethis::use_mit_license(name = "Craig McLean")
roxygen2::roxygenise()
library(Autotuner)
while(subsample) {
origDist <- stats::density(ppmObs, bw = 1)$y
set.seed(1)
newDist1 <-  stats::density(sample(ppmObs, checkPpm), bw = 1)$y
set.seed(2)
newDist2 <-  stats::density(sample(ppmObs, checkPpm), bw = 1)$y
set.seed(3)
newDist3 <-  stats::density(sample(ppmObs, checkPpm), bw = 1)$y
set.seed(4)
newDist4 <-  stats::density(sample(ppmObs, checkPpm), bw = 1)$y
set.seed(5)
newDist5 <-  stats::density(sample(ppmObs, checkPpm), bw = 1)$y
set.seed(6)
newDist6 <-  stats::density(sample(ppmObs, checkPpm), bw = 1)$y
set.seed(7)
newDist7 <-  stats::density(sample(ppmObs, checkPpm), bw = 1)$y
klDistance <- list()
subSamples <- ls()[grep("newDist",ls())]
for(j in seq_along(subSamples)) {
klDistance[[j]] <- suppressWarnings(entropy::KL.empirical(origDist,
get(subSamples[j])))
}
klDistance <- unlist(klDistance)
if(any(klDistance >= 0.5)) {
subsample <- F
} else {
checkPpm <- checkPpm/2
}
}
library(Autotuner)
library(Autotuner)
library(Autotuner)
library(Autotuner)
library(Autotuner)
library(Autotuner)
library(devtools)
devtools::create()
ls
library(Autotuner)
library(Autotuner)
library(Autotuner)
usethis::use_test("name")
library(testthat)
?test_check()
show()
?show()
mmetspFiles <- c(system.file("mzMLs/mtab_mmetsp_ft_120815_24.mzML", package = "mmetspData"),
system.file("mzMLs/mtab_mmetsp_ft_120815_25.mzML", package = "mmetspData"),
system.file("mzMLs/mtab_mmetsp_ft_120815_26.mzML", package = "mmetspData"))
runfile <- read.csv(system.file("mmetsp_metadata.csv", package = "mmetspData"),
stringsAsFactors = F)
runfile <- runfile[runfile$File.Name %in% sub(pattern = ".mzML", "", basename(mmetspFiles)),]
autotuner <- createAutotuner(mmetspFiles,
runfile,
file_col = "File.Name",
factorCol = "Sample.Type")
autotuner <- createAutotuner(mmetspFiles,
runfile,
file_col = "File.Name",
factorCol = "Sample.Type")
library(Autotuner)
mmetspFiles <- c(system.file("mzMLs/mtab_mmetsp_ft_120815_24.mzML", package = "mmetspData"),
system.file("mzMLs/mtab_mmetsp_ft_120815_25.mzML", package = "mmetspData"),
system.file("mzMLs/mtab_mmetsp_ft_120815_26.mzML", package = "mmetspData"))
runfile <- read.csv(system.file("mmetsp_metadata.csv", package = "mmetspData"),
stringsAsFactors = F)
runfile <- runfile[runfile$File.Name %in% sub(pattern = ".mzML", "", basename(mmetspFiles)),]
Autotuner <- createAutotuner(mmetspFiles,
runfile,
file_col = "File.Name",
factorCol = "Sample.Type")
Autotuner <- createAutotuner(mmetspFiles,
runfile,
file_col = "File.Name",
factorCol = "Sample.Type")
Autotuner
Autotuner@time
class(Autotuner@time)
expect_equal(class(Autotuner@time), "list")
expect_equal(class(Autotuner@time), "list")
unlist(Autotuner@time)
class(unlist(Autotuner@time))
expect_equal(class(unlist(Autotuner@time)), "numeric")
Autotuner@intensity
Autotuner@intensity
class(Autotuner@intensity)
class(unlist(Autotuner@time))
Autotuner@file_paths
class(Autotuner@file_paths)
Autotuner@file_paths
Autotuner@file_col
source('~/MIT/Research/Autotuner/tests/testthat.R', echo=TRUE)
Autotuner@time
class(Autotuner@time)
source('~/MIT/Research/Autotuner/tests/testthat/test_loadingData.R', echo=TRUE)
source('~/MIT/Research/Autotuner/tests/testthat.R', echo=TRUE)
source('~/MIT/Research/Autotuner/tests/testthat.R', echo=TRUE)
source('~/MIT/Research/Autotuner/tests/testthat/test_loadingData.R', echo=TRUE)
devtools::use_data()
## Checking if Autotuner is able to correctly subset data
## by metadata columns
Autotuner@metadata
source('~/MIT/Research/Autotuner/tests/testthat/test_loadingData.R', echo=TRUE)
lag <- 20
threshold<- 3
influence <- 0.1
signal <- lapply(Autotuner@intensity, ThresholdingAlgo, lag, threshold, influence)
signal
str(signal)
expect_equal(length(signal), 3)
signal <- lapply(Autotuner@intensity, ThresholdingAlgo, lag, threshold, influence)
signal
signal[[1]]
sapply(signal[[3]], function(x) {
all(is.na(x))
})
sum(sapply(signal[[3]], function(x) {
all(is.na(x))
}))
## check that computation took place
naCheck <- list()
for(i in seq_along(signal)) {
naCheck[[i]] <- sum(sapply(signal[[3]], function(x) {
all(is.na(x))
}))
}
naCheck
peaks <- extract_peaks(Autotuner = Autotuner, returned_peaks = 10,
signals = signal)
peaks
sapply(peaks, is.null)
peaks
expect_that(nullCount, 0)
nullCount <- sum(sapply(peaks, is.null))
expect_that(nullCount, 0)
nullCount
expect_equal(nullCount, 0)
nullCount
returned_peaks <- 10
returned_peaks <- 20
peaks <- extract_peaks(Autotuner = Autotuner, returned_peaks = returned_peaks,
signals = signal)
peaks
returned_peaks <- 7
peaks <- extract_peaks(Autotuner = Autotuner, returned_peaks = returned_peaks,
signals = signal)
peaks
returned_peaks <- 10
peaks <- extract_peaks(Autotuner = Autotuner, returned_peaks = returned_peaks,
signals = signal)
peaks
expect_equal(nrow(peaks[[1]]) <= returned_peaks, TRUE)
nrow(peaks[[1]])
ncol(peaks[[1]]) <= returned_peaks
expect_equal(ncol(peaks[[1]]) <= returned_peaks, TRUE)
returned_peaks <- 10
peak_table <- peakwidth_table(Autotuner = Autotuner,
peakList = peaks,
returned_peaks = returned_peaks)
peak_table
peak_time_difference(peak_table)
is.na(peak_table)
any(is.na(peak_table))
test_that(desc = "Checking Peakwidth_table",
code = {
expect_equal(any(is.na(peak_table)), FALSE)
})
peak_difference <- peak_time_difference(peak_table)
peak_difference
source('~/MIT/Research/Autotuner/tests/testthat/test_loadingData.R', echo=TRUE)
peak_difference
test_that(desc = "Checking peak_time_difference",
code = {
expect_equal(class(peak_difference), "data.frame")
})
?usethis::use_data()
usethis::use_data(Autotuner, peak_difference, peak_table)
?use_data_raw
use_data_raw(name = "Autotuner_tests")
usethis::use_data_raw("AutotunerTests")
# Checking input ----------------------------------------------------------
assertthat::assert_that(nrow(peak_table) > 0,
msg = "Peak table with 0 rows was entered into EICparams function.")
if(returnPpmPlots) {
if(!dir.exists(plotDir)) {
message("Directory in plotDir did not exist. Using the current working directory instead.")
plotDir <- "."
}
}
useGap = T
useGap <- T
returnPpmPlots <- F
massThresh <- 0.005
j <- 1
# itterating between samples ----------------------------------------------
data("data/peak_table.rda")
# itterating between samples ----------------------------------------------
system.file("peak_table.rda", package = "Autotuner")
data("peak_table", package=Autotuner, envir=parent.env(environment()))
data("peak_table", package="Autotuner", envir=parent.env(environment()))
library(Autotuner)
# itterating between samples ----------------------------------------------
system.file("peak_table.rda", package = "Autotuner")
data("peak_table", package="Autotuner", envir=parent.env(environment()))
data("peak_table", package="Autotuner")
data("peak_table", package="Autotuner")
peak_table
data("peak_difference", package="Autotuner")
data("Autotuner", package="Autotuner")
currentTable <- peak_table[peak_table$Sample == 1,]
currentFile <- Autotuner@file_paths[1]
currentFile
header <- suppressWarnings( MSnbase::header(msnObj))
allMzs <- MSnbase::mz(msnObj)
# Adding msnbase functionality to replace mzR API
msnObj <- suppressMessages(MSnbase::readMSData(files = currentFile,
mode = "onDisk",
msLevel. = 1))
observedPeak
header
mzDb
observedPeak
# itterating between samples ----------------------------------------------
system.file("peak_table.rda", package = "Autotuner")
data("peak_table", package="Autotuner")
data("peak_difference", package="Autotuner")
data("Autotuner", package="Autotuner")
currentTable <- peak_table[peak_table$Sample == 1,]
currentFile <- Autotuner@file_paths[1]
# Adding msnbase functionality to replace mzR API
msnObj <- suppressMessages(MSnbase::readMSData(files = currentFile,
mode = "onDisk",
msLevel. = 1))
header <- suppressWarnings( MSnbase::header(msnObj))
allMzs <- MSnbase::mz(msnObj)
allInt <- MSnbase::intensity(msnObj)
mzDb <- list()
for(i in seq_along(allInt)) {
mzDb[[i]] <- cbind(mz = allMzs[[i]],
intensity = allInt[[i]])
}
rm(allMzs, allInt, msnObj, i)
# going through each peak from a sample -----------------------------
curPeak <- 1
start <- currentTable[curPeak,"Start_time"]
end <- currentTable[curPeak,"End_time"]
width <- currentTable$peak_width[curPeak]
observedPeak <- list(start = start, end = end)
observedPeak
usethis::use_data(mzDb, header, observedPeak)
context("Performing Parameter Selection by Autotuner")
useGap <- T
returnPpmPlots <- F
massThresh <- 0.005
filename <- ''
data("mzDb", package="Autotuner")
data("header", package="Autotuner")
data("observedPeak", package="Autotuner")
## loading in the files to test if AutoTuner is correct
useGap <- T
returnPpmPlots <- F
massThresh <- 0.005
filename <- ''
data("mzDb", package="Autotuner")
library(Autotuner)
data("mzDb", package="Autotuner")
data("header", package="Autotuner")
data("observedPeak", package="Autotuner")
peak_table
scanDiff <- diff(header$retentionTime[header$msLevel == 1L])
rate <- mean(scanDiff)
rm(scanDiff)
sortedAllEIC <- dissectScans(mzDb,
observedPeak = observedPeak,
header = header)
sortedAllEIC
is.na(sortedAllEIC)
sum(is.na(sortedAllEIC))
apply(sortedAllEIC, 2, class)
expect_equal(unique(apply(sortedAllEIC, 2, class)), "numeric")
expect_false(nrow(sortedAllEIC) == 0)
# Checking if sorted scans pass mz error threshold ------------------------
matchedMasses <- rle(diff(sortedAllEIC$mz) < massThresh)
matchedMasses
sortedAllEIC$mz
diff(sortedAllEIC$mz)
# Checking if sorted scans pass mz error threshold ------------------------
matchedMasses <- rle(diff(sortedAllEIC$mz) < massThresh)
### THIS COULD BE PLACE TO ADD NOISE FILTER TO MAKE SPEED FASTER
noiseAndPeaks <- filterPeaksfromNoise(matchedMasses)
noiseAndPeaks
no_match <- noiseAndPeaks[[1]]
truePeaks <- noiseAndPeaks[[2]]
rm(noiseAndPeaks)
no_match
test_that(desc = "Testing noise filtering",
code = {
expect_false(length(no_match) == 0)
expect_false(length(truePeaks) == 0)
})
approvedPeaks <- findTruePeaks(truePeaks, sortedAllEIC)
approvedPeaks
message("-------- Number of bins retained after checking that features within bins come from consecutive scans: ",
nrow(approvedPeaks))
approvedPeaks
overlappingScans <- sum(approvedPeaks$multipleInScan)
overlappingScans
approvedPeaks
overlappingScans
ppmEst <- filterPpmError(approvedPeaks, useGap, varExpThresh,
returnPpmPlots, plotDir, observedPeak,
filename)
ppmEst
ppmEst <- suppressMessages(filterPpmError(approvedPeaks, useGap, varExpThresh,
returnPpmPlots, plotDir, observedPeak,
filename))
ppmEst
test_that(desc = "Testing ppm estimation",
code = {
expect_equal(length(ppmEst), 1)
expect_equal(class(ppmEst), "numeric")
})
ppmObs <- approvedPeaks$meanPPM
ppmObs <- strsplit(split = ";", x = as.character(ppmObs))
ppmObs <- sapply(ppmObs, as.numeric)
noisyBin <- lapply(ppmObs, function(ppm) {
any(ppm > ppmEst)
})
noisyBin <- unlist(noisyBin)
approvScorePeaks <- approvedPeaks[!noisyBin,]
approvScorePeaks <- approvedPeaks[!noisyBin,]
approvScorePeaks
# Estimating PeakPicking Parameters ---------------------------------------
SNest <- estimateSNThresh(no_match,
sortedAllEIC, approvScorePeaks)
SNest
SNest <- min(SNest)
assertthat::assert_that(!is.na(SNest),
msg = "Output of estimateSNThresh within checkEICPeaks was NA. Something went wrong here.")
scanEst <- min(approvScorePeaks$scanCount)
### Noise Intensity Estimate
noiseEst <- min(approvScorePeaks$minIntensity) - 100
if(noiseEst < 0) {
noiseEst <- min(approvScorePeaks$minIntensity) + 10
}
### Prefilter Intensity Estimate
intensityEst <- min(approvScorePeaks$Intensity)/sqrt(2)
intensityEst
### peakWidth Estimate
maxPw <- findPeakWidth(approvScorePeaks = approvScorePeaks,
mzDb = mzDb,
header = header,
sortedAllEIC = sortedAllEIC,
boundaries = boundaries,
ppmEst = ppmEst)
boundaries
boundaries
### peakWidth Estimate
boundaries <- range(sortedAllEIC$scanID)
maxPw <- findPeakWidth(approvScorePeaks = approvScorePeaks,
mzDb = mzDb,
header = header,
sortedAllEIC = sortedAllEIC,
boundaries = boundaries,
ppmEst = ppmEst)
maxPw
test_that(desc = "Testing Max Peakwidth Estimate",
code = {
expect_equal(class(maxPw), "numeric")
expect_false(is.na(maxPw))
})
minPw <- scanEst * rate
## 2019-06-19
## fixed this since peakwidth estimate functions should return scalars
if(maxPw < 5*minPw) {
message("Expanding Max Peakwidth")
maxPw <- maxPw*2
}
source('~/MIT/Research/Autotuner/tests/testthat/test_Autotuner.R', echo=TRUE)
expect_equal(class(approvedPeaks), "data.frame")
expect_false(nrow(approvedPeaks) > 0)
nrow(approvedPeaks)
nrow(approvedPeaks) > 0
overlappingScans <- sum(approvedPeaks$multipleInScan)
ppmEst <- suppressMessages(filterPpmError(approvedPeaks, useGap, varExpThresh,
returnPpmPlots, plotDir, observedPeak,
filename))
test_that(desc = "Testing ppm estimation",
code = {
expect_equal(length(ppmEst), 1)
expect_equal(class(ppmEst), "numeric")
expect_false(is.na(ppmEst))
})
ppmObs <- approvedPeaks$meanPPM
ppmObs <- strsplit(split = ";", x = as.character(ppmObs))
ppmObs <- sapply(ppmObs, as.numeric)
noisyBin <- lapply(ppmObs, function(ppm) {
any(ppm > ppmEst)
})
noisyBin <- unlist(noisyBin)
approvScorePeaks <- approvedPeaks[!noisyBin,]
SNest <- estimateSNThresh(no_match,
sortedAllEIC, approvScorePeaks)
test_that(desc = "Testing s/n Estimation",
code = {
expect_equal(class(SNest), "numeric")
expect_false(is.na(SNest))
})
is.na(SNest)
SNest
any(is.na(SNest))
expect_false(any(is.na(SNest)))
expect_equal(class(SNest), "numeric")
test_that(desc = "Testing s/n Estimation",
code = {
expect_equal(class(SNest), "numeric")
expect_false(any(is.na(SNest)))
})
SNest <- min(SNest)
scanEst <- min(approvScorePeaks$scanCount)
### Noise Intensity Estimate
noiseEst <- min(approvScorePeaks$minIntensity) - 100
if(noiseEst < 0) {
noiseEst <- min(approvScorePeaks$minIntensity) + 10
}
### Prefilter Intensity Estimate
intensityEst <- min(approvScorePeaks$Intensity)/sqrt(2)
### peakWidth Estimate
boundaries <- range(sortedAllEIC$scanID)
maxPw <- findPeakWidth(approvScorePeaks = approvScorePeaks,
mzDb = mzDb,
header = header,
sortedAllEIC = sortedAllEIC,
boundaries = boundaries,
ppmEst = ppmEst)
test_that(desc = "Testing Max Peakwidth Estimate",
code = {
expect_equal(class(maxPw), "numeric")
expect_false(is.na(maxPw))
})
