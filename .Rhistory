back <- "netCDF"
} else {
back <- "pwiz"
}
currentMsFile <- mzR::openMSfile(currentFile, backend = back)
rm(currentFile)
# going through each peak from a sample -----------------------------
pickedParams <- list()
curPeak <- 1
start <- currentTable[curPeak,"Start_time"]
end <- currentTable[curPeak,"End_time"]
width <- currentTable$peak_width[curPeak]
observedPeak <- list(start = start, end = end)
massThresh = 0.01
# extracting ms1 information for current peak -----------------------------
suppressWarnings(rm(no_match,approvedPeaks))
sampleChrom <- mzR::header(currentMsFile)
scanDiff <- diff(sampleChrom$retentionTime[sampleChrom$msLevel == 1L])
rate <- mean(scanDiff)
rm(scanDiff)
sortedAllEIC <- dissectScans(currentMsFile, observedPeak, sampleChrom)
sortedAllEIC
assertthat::assert_that(nrow(sortedAllEIC) > 0,
msg = "Check dissectScans within checkEICPeaks. A table with 0 rows was returned. Make sure correct TIC peaks were selected.")
boundaries <- range(sortedAllEIC$dataMatchIndex)
boundaries
# Checking if sorted scans pass mz error threshold ------------------------
matchedMasses <- rle(diff(sortedAllEIC$mz) < massThresh)
noiseAndPeaks <- filterPeaksfromNoise(matchedMasses)
no_match <- noiseAndPeaks[[1]]
truePeaks <- noiseAndPeaks[[2]]
rm(noiseAndPeaks)
approvedPeaks <- findTruePeaks(truePeaks, sortedAllEIC)
if(nrow(approvedPeaks) == 0) {
message("No observed m/z value met was observed across adjacent scans below an error of massThresh.")
return(NULL)
}
library(cluster)
ppmObs <- approvedPeaks$meanPPM
ppmObs <- strsplit(split = ";", x = as.character(ppmObs)) %>%
sapply(as.numeric) %>%
unlist()
library(magrittr)
ppmObs <- approvedPeaks$meanPPM
ppmObs <- strsplit(split = ";", x = as.character(ppmObs)) %>%
sapply(as.numeric) %>%
unlist()
totalPPM <- length(ppmObs)
## estimating clustering based on hard coded 80% Vexp threshold
clustCount <- 1
varExp <- 0
clusGap(ppmObs, FUNcluster = kmeans)
clusGap(dist(ppmObs), FUNcluster = kmeans)
clusGap(as.matrix(dist(ppmObs)), FUNcluster = kmeans)
clusGap(as.matrix(dist(ppmObs)), FUNcluster = kmeans, K.max = length(ppmObs)/2)
clusGap(x = as.matrix(dist(ppmObs)), FUNcluster = kmeans, K.max = 10)
?clusGap
clusGap(x = as.matrix(dist(ppmObs)), FUNcluster = kmeans, K.max = 5, B = 5)
clusGap(x = as.matrix(ppmObs), FUNcluster = kmeans, K.max = 5, B = 5)
clusGap(x = as.matrix(ppmObs), FUNcluster = kmeans, K.max = 10, B = 10)
ppmObs
as.matrix(ppmObs)
clusGap(x = ppmObs, FUNcluster = kmeans, K.max = 10, B = 10)
dim(ppmObs)
dim(as.matrix(ppmObs))
clusGap(x = as.matrix(ppmObs), FUNcluster = kmeans, K.max = 10, B = 10)
while(varExp < .8 && clustCount < length(ppmObs)/2) {
kmeansPPM <- kmeans(ppmObs, clustCount)
varExp <- kmeansPPM$betweenss/kmeansPPM$totss
print(varExp)
clustCount <- clustCount + 1
}
clusGap(x = as.matrix(ppmObs), FUNcluster = kmeans, K.max = 10, B = 100)
clusGap(x = as.matrix(ppmObs), FUNcluster = kmeans, K.max = 10, B = 10)
cluster::clusGap(x = as.matrix(ppmObs), FUNcluster = kmeans,
K.max = 5,
B = 10)
?clusGap
suppressMessages(cluster::clusGap(x = as.matrix(ppmObs),
FUNcluster = kmeans,
K.max = 5,
B = 10))
suppressMessages(cluster::clusGap(x = as.matrix(ppmObs),
FUNcluster = kmeans,
K.max = 5,
B = 10))
suppressMessages(cluster::clusGap(x = as.matrix(ppmObs),
FUNcluster = kmeans,
K.max = 10,
B = 10,
verbose = F))
gapStat <- cluster::clusGap(x = as.matrix(ppmObs),
FUNcluster = kmeans,
K.max = 10,
B = 10,
verbose = F)
gapStat <- gapStat[-1,]
gapStat
gapStat$Tab[-1,]
gapStat <- gapStat$Tab[-1,]
diff(gapStat[,3])
diff(-gapStat[,3])
which(diff(-gapStat[,3]) > 0)
which.min(diff(-gapStat[,3]) > 0)
which(diff(-gapStat[,3]) > 0)
min(which(diff(-gapStat[,3]) > 0)) + 1
kmeansPPM
kmeansPPM <- kmeans(ppmObs, clusters)
kmeansPPM
kmeansPPM <- kmeans(ppmObs, clusters)
clusters <- min(which(diff(-gapStat[,3]) > 0)) + 1
kmeansPPM <- kmeans(ppmObs, clusters)
kmeansPPM
source('~/MIT/Research/Autotuner/R/checkEICFunctions.R', echo=TRUE)
# Filtering data by variability and ppm checks ----------------------------
ppmEst <- filterPpmError(approvedPeaks)
ppmEst
for(curPeak in 1:nrow(currentTable)) {
start <- currentTable[curPeak,"Start_time"]
end <- currentTable[curPeak,"End_time"]
width <- currentTable$peak_width[curPeak]
observedPeak <- list(start = start, end = end)
## currently here
estimatedPeakParams <- checkEICPeaks(currentMsFile = currentMsFile,
observedPeak = observedPeak,
massThresh)
if(is.null(estimatedPeakParams)) {
next
}
pickedParams[[curPeak]] <- cbind(estimatedPeakParams,
startTime = start,
endTime = end,
sampleID = j)
}
for(curPeak in 1:nrow(currentTable)) {
start <- currentTable[curPeak,"Start_time"]
end <- currentTable[curPeak,"End_time"]
width <- currentTable$peak_width[curPeak]
observedPeak <- list(start = start, end = end)
## currently here
estimatedPeakParams <- checkEICPeaks(currentMsFile = currentMsFile,
observedPeak = observedPeak,
massThresh)
if(is.null(estimatedPeakParams)) {
next
}
pickedParams[[curPeak]] <- cbind(estimatedPeakParams,
startTime = start,
endTime = end,
sampleID = j)
}
message(clusters)
source('~/MIT/Research/Autotuner/R/checkEICFunctions.R', echo=TRUE)
for(curPeak in 1:nrow(currentTable)) {
start <- currentTable[curPeak,"Start_time"]
end <- currentTable[curPeak,"End_time"]
width <- currentTable$peak_width[curPeak]
observedPeak <- list(start = start, end = end)
## currently here
estimatedPeakParams <- checkEICPeaks(currentMsFile = currentMsFile,
observedPeak = observedPeak,
massThresh)
if(is.null(estimatedPeakParams)) {
next
}
pickedParams[[curPeak]] <- cbind(estimatedPeakParams,
startTime = start,
endTime = end,
sampleID = j)
}
pickedParams
sampleParams <- Reduce(rbind, pickedParams)
sampleParams
weighted.mean(sampleParams$ppm, sampleParams$peakCount)
curPeak <- 6
start <- currentTable[curPeak,"Start_time"]
end <- currentTable[curPeak,"End_time"]
width <- currentTable$peak_width[curPeak]
observedPeak <- list(start = start, end = end)
# extracting ms1 information for current peak -----------------------------
suppressWarnings(rm(no_match,approvedPeaks))
sampleChrom <- mzR::header(currentMsFile)
scanDiff <- diff(sampleChrom$retentionTime[sampleChrom$msLevel == 1L])
rate <- mean(scanDiff)
rm(scanDiff)
sortedAllEIC <- dissectScans(currentMsFile, observedPeak, sampleChrom)
assertthat::assert_that(nrow(sortedAllEIC) > 0,
msg = "Check dissectScans within checkEICPeaks. A table with 0 rows was returned. Make sure correct TIC peaks were selected.")
boundaries <- range(sortedAllEIC$dataMatchIndex)
# Checking if sorted scans pass mz error threshold ------------------------
matchedMasses <- rle(diff(sortedAllEIC$mz) < massThresh)
noiseAndPeaks <- filterPeaksfromNoise(matchedMasses)
no_match <- noiseAndPeaks[[1]]
truePeaks <- noiseAndPeaks[[2]]
rm(noiseAndPeaks)
approvedPeaks <- findTruePeaks(truePeaks, sortedAllEIC)
if(nrow(approvedPeaks) == 0) {
message("No observed m/z value met was observed across adjacent scans below an error of massThresh.")
return(NULL)
}
# Filtering data by variability and ppm checks ----------------------------
ppmEst <- filterPpmError(approvedPeaks)
ppmEst
ppmObs <- approvedPeaks$meanPPM
ppmObs <- strsplit(split = ";", x = as.character(ppmObs)) %>%
sapply(as.numeric) %>%
unlist()
totalPPM <- length(ppmObs)
## estimating clustering based on hard coded 80% Vexp threshold
clustCount <- 1
varExp <- 0
gapStat <- cluster::clusGap(x = as.matrix(ppmObs),
FUNcluster = kmeans,
K.max = 10,
B = 10,
verbose = F)
gapStat <- gapStat$Tab[-1,]
clusters <- min(which(diff(-gapStat[,3]) > 0)) + 1
kmeansPPM <- kmeans(ppmObs, clusters)
kmeansPPM
gapStat
diff(-gapStat[,3]) > 0)
diff(-gapStat[,3]) > 0)
-gapStat[,3]
diff(-gapStat[,3])
gapStat[,3]
diff(gapStat[,3])
gapStat
clusters <- 3
kmeansPPM <- kmeans(ppmObs, clusters)
kmeansPPM
gapStat
gapStat <- cluster::clusGap(x = as.matrix(ppmObs),
FUNcluster = kmeans,
K.max = 10,
B = 10,
verbose = F)
gapStat <- gapStat$Tab[-1,]
clusters <- min(which(diff(gapStat[,3]) > 0)) + 1
kmeansPPM <- kmeans(ppmObs, clusters)
message(clusters)
## estimating clustering based on hard coded 80% Vexp threshold
clustCount <- 1
varExp <- 0
gapStat <- cluster::clusGap(x = as.matrix(ppmObs),
FUNcluster = kmeans,
K.max = 10,
B = 10,
verbose = F)
gapStat <- gapStat$Tab[-1,]
clusters <- min(which(diff(gapStat[,3]) > 0)) + 1
kmeansPPM <- kmeans(ppmObs, clusters)
message(clusters)
## cluster which contains smallest ppm values
clusterSize <- table(kmeansPPM$cluster) %>% sort(decreasing = T)
maxCluster <- names(clusterSize)[1]
minCluster <- which(kmeansPPM$cluster == maxCluster)
rm(clusterSize)
x <- ppmObs
n <- length(x)
h <- 1
gauss <- function(x) 1/sqrt(2*pi) * exp(-(x^2)/2)
gaussDKE <- function(a, x) gauss((x - a)/h)/(n * h)
bumps <- sapply(ppmObs[minCluster], gaussDKE, x)
OutlierScore <- sapply(1:n, function(xx) {
rowSums(bumps)[xx]/(sum(rowSums(bumps))/n)
})
scoreSub <- which(OutlierScore > 1)
ppmEst <- max(ppmObs[scoreSub])
ppmEst
ppmObs[scoreSub]
mean(ppmObs[scoreSub])
ppmEst + sd(ppmObs[scoreSub])*3
ppmEst <- mean(ppmObs[scoreSub])
ppmEst <- ppmEst + sd(ppmObs[scoreSub])*3
ppmEst
clusters <- min(which(diff(gapStat[,3]) > 0))
kmeansPPM <- kmeans(ppmObs, clusters)
message(clusters)
## cluster which contains smallest ppm values
clusterSize <- table(kmeansPPM$cluster) %>% sort(decreasing = T)
maxCluster <- names(clusterSize)[1]
minCluster <- which(kmeansPPM$cluster == maxCluster)
rm(clusterSize)
x <- ppmObs
n <- length(x)
h <- 1
gauss <- function(x) 1/sqrt(2*pi) * exp(-(x^2)/2)
gaussDKE <- function(a, x) gauss((x - a)/h)/(n * h)
bumps <- sapply(ppmObs[minCluster], gaussDKE, x)
OutlierScore <- sapply(1:n, function(xx) {
rowSums(bumps)[xx]/(sum(rowSums(bumps))/n)
})
scoreSub <- which(OutlierScore > 1)
max(ppmObs[scoreSub])
ppmEst <- max(ppmObs[scoreSub])
ppmEst <- ppmEst + sd(ppmObs[scoreSub])*3
ppmEst
gapStat <- cluster::clusGap(x = as.matrix(ppmObs),
FUNcluster = kmeans,
K.max = 10,
B = 10,
verbose = F)
gapStat$Tab
gapStat <- gapStat$Tab
min(which(diff(gapStat[,3]) > 0))
which(diff(gapStat[,3]) > 0)
diff(gapStat[,3])
diff(gapStat[,3]) > 0
which(diff(gapStat[,3]) > 0)
clusters <- min(which(diff(gapStat[,3]) > 0)) + 1
kmeansPPM <- kmeans(ppmObs, clusters)
kmeansPPM
## cluster which contains smallest ppm values
clusterSize <- table(kmeansPPM$cluster) %>% sort(decreasing = T)
maxCluster <- names(clusterSize)[1]
minCluster <- which(kmeansPPM$cluster == maxCluster)
rm(clusterSize)
x <- ppmObs
n <- length(x)
h <- 1
gauss <- function(x) 1/sqrt(2*pi) * exp(-(x^2)/2)
gaussDKE <- function(a, x) gauss((x - a)/h)/(n * h)
bumps <- sapply(ppmObs[minCluster], gaussDKE, x)
OutlierScore <- sapply(1:n, function(xx) {
rowSums(bumps)[xx]/(sum(rowSums(bumps))/n)
})
scoreSub <- which(OutlierScore > 1)
ppmEst <- max(ppmObs[scoreSub])
ppmEst <- ppmEst + sd(ppmObs[scoreSub])*3
ppmEst
source('~/MIT/Research/Autotuner/R/checkEICFunctions.R', echo=TRUE)
curPeak
curPeak <- 1
start <- currentTable[curPeak,"Start_time"]
end <- currentTable[curPeak,"End_time"]
width <- currentTable$peak_width[curPeak]
observedPeak <- list(start = start, end = end)
# extracting ms1 information for current peak -----------------------------
suppressWarnings(rm(no_match,approvedPeaks))
sampleChrom <- mzR::header(currentMsFile)
scanDiff <- diff(sampleChrom$retentionTime[sampleChrom$msLevel == 1L])
rate <- mean(scanDiff)
rm(scanDiff)
sortedAllEIC <- dissectScans(currentMsFile, observedPeak, sampleChrom)
assertthat::assert_that(nrow(sortedAllEIC) > 0,
msg = "Check dissectScans within checkEICPeaks. A table with 0 rows was returned. Make sure correct TIC peaks were selected.")
boundaries <- range(sortedAllEIC$dataMatchIndex)
# Checking if sorted scans pass mz error threshold ------------------------
matchedMasses <- rle(diff(sortedAllEIC$mz) < massThresh)
noiseAndPeaks <- filterPeaksfromNoise(matchedMasses)
no_match <- noiseAndPeaks[[1]]
truePeaks <- noiseAndPeaks[[2]]
rm(noiseAndPeaks)
approvedPeaks <- findTruePeaks(truePeaks, sortedAllEIC)
if(nrow(approvedPeaks) == 0) {
message("No observed m/z value met was observed across adjacent scans below an error of massThresh.")
return(NULL)
}
# Filtering data by variability and ppm checks ----------------------------
ppmEst <- filterPpmError(approvedPeaks)
ppmEst
ppmObs <- approvedPeaks$meanPPM
ppmObs <- strsplit(split = ";", x = as.character(ppmObs)) %>%
sapply(as.numeric) %>%
unlist()
totalPPM <- length(ppmObs)
## estimating clustering based on hard coded 80% Vexp threshold
clustCount <- 1
varExp <- 0
gapStat <- cluster::clusGap(x = as.matrix(ppmObs),
FUNcluster = kmeans,
K.max = 10,
B = 10,
verbose = F)
gapStat <- gapStat$Tab
gapStat
gapStat <- cluster::clusGap(x = as.matrix(ppmObs),
FUNcluster = kmeans,
K.max = 10,
B = 10,
verbose = F)
gapStat
gapStat$n
gapStat$B
gapStat$call
gapStat$spaceH0
gapStat$FUNcluster()
gapStat$call
gapStat
maxSE(gapStat)
gapStat
clusters
kmeans(ppmObs, clusters)
kmeansPPM <- kmeans(ppmObs, clusters)
## cluster which contains smallest ppm values
clusterSize <- table(kmeansPPM$cluster) %>% sort(decreasing = T)
maxCluster <- names(clusterSize)[1]
minCluster <- which(kmeansPPM$cluster == maxCluster)
rm(clusterSize)
x <- ppmObs
n <- length(x)
h <- 1
gauss <- function(x) 1/sqrt(2*pi) * exp(-(x^2)/2)
gaussDKE <- function(a, x) gauss((x - a)/h)/(n * h)
bumps <- sapply(ppmObs[minCluster], gaussDKE, x)
OutlierScore <- sapply(1:n, function(xx) {
rowSums(bumps)[xx]/(sum(rowSums(bumps))/n)
})
scoreSub <- which(OutlierScore > 1)
ppmEst <- max(ppmObs[scoreSub])
ppmEst <- ppmEst + sd(ppmObs[scoreSub])*3
ppmEst
gapStat <- cluster::clusGap(x = as.matrix(ppmObs),
FUNcluster = kmeans,
K.max = 5,
B = 10,
verbose = F)
gapStat
gapStat <- cluster::clusGap(x = as.matrix(ppmObs),
FUNcluster = kmeans,
K.max = 5,
B = 10,
verbose = F)
gapStat <- gapStat$Tab
gapStat
diff(gapStat[,3])
gapStat
gapStat[,3]
diff(gapStat[,3])
diff(-gapStat[,3])
which(diff(-gapStat[,3]) > 0)
min(which(diff(-gapStat[,3]) > 0)) + 1
clusters <- min(which(diff(-gapStat[,3]) > 0)) + 1
kmeansPPM <- kmeans(ppmObs, clusters)
kmeansPPM
kmeansPPM
source('~/MIT/Research/Autotuner/R/checkEICFunctions.R', echo=TRUE)
# going through each peak from a sample -----------------------------
pickedParams <- list()
for(curPeak in 1:nrow(currentTable)) {
start <- currentTable[curPeak,"Start_time"]
end <- currentTable[curPeak,"End_time"]
width <- currentTable$peak_width[curPeak]
observedPeak <- list(start = start, end = end)
## currently here
estimatedPeakParams <- checkEICPeaks(currentMsFile = currentMsFile,
observedPeak = observedPeak,
massThresh)
if(is.null(estimatedPeakParams)) {
next
}
pickedParams[[curPeak]] <- cbind(estimatedPeakParams,
startTime = start,
endTime = end,
sampleID = j)
}
pickedParams
sampleParams <- Reduce(rbind, pickedParams)
weighted.mean(sampleParams$ppm, sampleParams$peakCount)
## this function is autotuner
eicParamEsts <- EICparams(Autotuner = autotuner,
massThresh = .01,
peak_table = peak_table)
eicParamEsts
## checking colnames of current table
colNameCheck <- all(c("ppm", "peakCount", "noiseThreshold", "prefilterI", "prefilterScan",
"TenPercentQuanSN","maxPw", "minPw") %in% colnames(eicParamEsts))
assertthat::assert_that(colNameCheck,
msg = "Error in EICparams: some of the column names from the output are missing. Cannot complete parameter estimation.")
ppmEst <- weighted.mean(eicParamEsts$ppm, eicParamEsts$peakCount)
ppmEst
noiseEst <- min(eicParamEsts$noiseThreshold, na.rm = T)
prefilterIEst <- min(eicParamEsts$prefilterI, na.rm = T)
prefilterScanEst <- min(eicParamEsts$prefilterScan, na.rm = T)
snEst <- min(eicParamEsts$TenPercentQuanSN, na.rm = T)
maxPw <- max(eicParamEsts$maxPw)
minPw <- min(eicParamEsts$maxPw)
estimates <- c(ppm = ppmEst,
noise = noiseEst,
preIntensity = prefilterIEst,
preScan = prefilterScanEst,
snThresh = snEst,
"Max Peakwidth" = maxPw,
"Min Peakwidth" = minPw)
estimates
sd(eicParamEsts$ppm)
ppmEst
ppmSd <- sd(eicParamEsts$ppm)
noiseSd <- sd(eicParamEsts$noiseThreshold)
prefilSd <- sd(eicParamEsts$prefilterI, na.rm = T)
prefilScanSd <- sd(eicParamEsts$prefilterScan, na.rm = T)
snEstSd <- sd(eicParamEsts$TenPercentQuanSN, na.rm = T)
maxPwDist <- abs(diff(sort(eicParamEsts$maxPw, decreasing = T))[1])
minPwDist <- abs(diff(sort(eicParamEsts$minPw, decreasing = T))[2])
variability <- c(ppmSd, noiseSd, prefilSd, prefilScanSd, snEstSd,
maxPwDist,
minPwDist)
rm(ppmSd, noiseSd, prefilSd, prefilScanSd, snEstSd, maxPwDist, minPwDist)
description <- c("Standard Deviation of all PPM Estimates",
"Standard Deviation of all noise Estimates",
'Standard Deviation of all prefileter Intensity Estimates',
"Standard Deviation of all scan coung Estimates",
"Standard Deviation of all s/n threshold Estimates",
"Distance between two highest estimated peak widths",
"Distance between two lowest estimated peak widths")
aggregatedEstimates <- data.frame(Parameters = names(estimates),
estimates = signif(estimates, digits = 4),
'Variability Measure' = signif(variability, digits = 4),
"Measure" = description)
aggregatedEstimates
library(Autotuner)
