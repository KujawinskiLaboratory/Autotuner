signals <- lapply(getAutoIntensity(Autotuner),
ThresholdingAlgo, lag, threshold, influence)
plot_signals(Autotuner,
threshold,
## index for which data files should be displayed
sample_index = 1:3,
signals = signals)
rm(lag, influence, threshold)
Autotuner <- isolatePeaks(Autotuner, returned_peaks = 10, signals)
for(i in unique(peak_difference$index)) {
plot_peaks(Autotuner = Autotuner,
boundary = 100,
peak = i)
}
massThresh = .005
verbose = F
returnPpmPlots = F
useGap = T
peak_table <- Autotuner@peak_table
# Checking input ----------------------------------------------------------
assertthat::assert_that(nrow(peak_table) > 0,
msg = "Peak table with 0 rows was entered into EICparams function.")
if(returnPpmPlots) {
if(!dir.exists(plotDir)) {
message("Directory in plotDir did not exist. Using the current working directory instead.")
plotDir <- "."
}
}
# itterating between samples ----------------------------------------------
totalEstimates <- list()
j <- 1
message("Currently on sample ", j)
currentTable <- peak_table[peak_table$Sample == j,]
currentFile <- Autotuner@file_paths[j]
# Adding msnbase functionality to replace mzR API
msnObj <- suppressMessages(MSnbase::readMSData(files = currentFile,
mode = "onDisk",
msLevel. = 1))
header <- suppressWarnings( MSnbase::header(msnObj))
allMzs <- MSnbase::mz(msnObj)
allInt <- MSnbase::intensity(msnObj)
mzDb <- list()
for(i in seq_along(allInt)) {
mzDb[[i]] <- cbind(mz = allMzs[[i]],
intensity = allInt[[i]])
}
rm(allMzs, allInt, msnObj, i)
# going through each peak from a sample -----------------------------
pickedParams <- list()
curPeak <- 1
message("--- Currently on peak: ", curPeak)
start <- currentTable[curPeak,"Start_time"]
end <- currentTable[curPeak,"End_time"]
width <- currentTable$peak_width[curPeak]
observedPeak <- list(start = start, end = end)
filename = basename(currentFile)
# extracting ms1 information for current peak -----------------------------
## msnObj
suppressWarnings(rm(no_match,approvedPeaks))
scanDiff <- diff(header$retentionTime[header$msLevel == 1L])
rate <- mean(scanDiff)
rm(scanDiff)
sortedAllEIC <- dissectScans(mzDb,
observedPeak = observedPeak,
header = header)
assertthat::assert_that(nrow(sortedAllEIC) > 0,
msg = "Check dissectScans within checkEICPeaks. A table with 0 rows was returned. Make sure correct TIC peaks were selected.")
assertthat::assert_that(!all(is.na(sortedAllEIC$scanID)),
msg = "There was a problem finding spectrum IDs within header file for this data. Error occured after function 'dissectScans'.")
boundaries <- range(sortedAllEIC$scanID)
# Checking if sorted scans pass mz error threshold ------------------------
matchedMasses <- rle(diff(sortedAllEIC$mz) < massThresh)
### THIS COULD BE PLACE TO ADD NOISE FILTER TO MAKE SPEED FASTER
noiseAndPeaks <- filterPeaksfromNoise(matchedMasses)
no_match <- noiseAndPeaks[[1]]
truePeaks <- noiseAndPeaks[[2]]
rm(noiseAndPeaks)
message("-------- Number of bins detected with absolute mass error threshold: ",
length(truePeaks))
approvedPeaks <- findTruePeaks(truePeaks, sortedAllEIC)
message("-------- Number of bins retained after checking that features within bins come from consecutive scans: ",
nrow(approvedPeaks))
message("-------- ", signif(nrow(approvedPeaks)/length(truePeaks)*100, digits = 2),
" % of bins retained after checking that features come from consecutive scans")
overlappingScans <- sum(approvedPeaks$multipleInScan)
message("-------- Number of bins with scans with 2+ mass observations: ",
overlappingScans)
if(nrow(approvedPeaks) == 0) {
message("No observed m/z value met was observed across adjacent scans below an error of massThresh.")
return(NULL)
}
ppmObs <- approvedPeaks$meanPPM
ppmObs <- strsplit(split = ";", x = as.character(ppmObs)) %>%
lapply(function(x) {as.numeric(x)}) %>%
unlist()
## 2019-06-19
## corner case when all error measurements are identical.
if(diff(range(ppmObs)) < .Machine$double.eps ^ 0.5) {
stop("All calculated ppm values are identical. Error of data may be higher than the mass threshold value.")
}
message("-------- Number of ppm value across bins: ", length(ppmObs))
if(length(ppmObs) > 10000) {
ppmObs <- ppmObs[sample(x = 1:length(ppmObs), size = 5000)]
}
if(length(ppmObs) > 750) {
checkPpm <- length(ppmObs)/2
subsample <- T
while(subsample) {
origDist <- stats::density(ppmObs, bw = 1)$y
set.seed(1)
newDist1 <-  stats::density(sample(ppmObs, checkPpm), bw = 1)$y
set.seed(2)
newDist2 <-  stats::density(sample(ppmObs, checkPpm), bw = 1)$y
set.seed(3)
newDist3 <-  stats::density(sample(ppmObs, checkPpm), bw = 1)$y
set.seed(4)
newDist4 <-  stats::density(sample(ppmObs, checkPpm), bw = 1)$y
set.seed(5)
newDist5 <-  stats::density(sample(ppmObs, checkPpm), bw = 1)$y
set.seed(6)
newDist6 <-  stats::density(sample(ppmObs, checkPpm), bw = 1)$y
set.seed(7)
newDist7 <-  stats::density(sample(ppmObs, checkPpm), bw = 1)$y
klDistance <- list()
subSamples <- ls()[grep("newDist",ls())]
for(j in seq_along(subSamples)) {
klDistance[[j]] <- suppressWarnings(entropy::KL.empirical(origDist,
get(subSamples[j])))
}
klDistance <- unlist(klDistance)
if(any(klDistance >= 0.5)) {
subsample <- F
} else {
checkPpm <- checkPpm/2
}
}
ppmObs <- sample(ppmObs, checkPpm)
message("-------- Number of ppm value across bins after KL Distance Filtering: ",
length(ppmObs))
}
## 2019-04-09 added this here since it doesn't make sense to cluster too few
## features
if(length(ppmObs) < 100) {
kmeansPPM <- kmeans(ppmObs, 1)
} else if(useGap) {
gapStat <- cluster::clusGap(x = as.matrix(ppmObs),
FUNcluster = kmeans,
K.max = 5,
B = 7,
verbose = F)
gapStat <- gapStat$Tab
gap <- diff(-gapStat[,3]) > 0
if(any(gap)) {
clusters <- max(which(gap)) + 1
} else {
clusters <- 1
}
kmeansPPM <- kmeans(ppmObs, clusters)
} else {
## estimating clustering based on hard coded 80% Vexp threshold
clustCount <- 1
varExp <- 0
while(varExp < varExpThresh && clustCount < length(ppmObs)/2) {
kmeansPPM <- kmeans(ppmObs, clustCount)
varExp <- kmeansPPM$betweenss/kmeansPPM$totss
clustCount <- clustCount + 1
}
}
## cluster which contains smallest ppm values
clusterSize <- table(kmeansPPM$cluster) %>% sort(decreasing = T)
maxCluster <- names(clusterSize)[1]
minCluster <- which(kmeansPPM$cluster == maxCluster)
rm(clusterSize)
x <- ppmObs
n <- length(x)
h <- 1
## delete this later
gauss <- function(x) 1/sqrt(2*pi) * exp(-(x^2)/2)
gaussDKE <- function(a, x) gauss((x - a)/h)/(n * h)
## this object is huge - 2.7 Gb
bumps <- sapply(ppmObs[minCluster], gaussDKE, x)
wholeKDE <- sapply(ppmObs, gaussDKE, x)
## calculating this ahead of time to avoid unnecessary downstream
## math
cKdeMean <- sum(rowSums(bumps))/length(minCluster)
OutlierScore <- rowSums(wholeKDE)/(cKdeMean)
scoreSub <- which(OutlierScore > 1)
ppmEst <- max(ppmObs[scoreSub])
maxX <- ppmEst
ppmEst <- ppmEst + sd(ppmObs[scoreSub])*3
plot(stats::density(ppmObs,bw = 1), main = title, cex.main = .7) +
abline(v = maxX, lty = 2, col = "red") +
abline(v = ppmEst, lty = 3, col = "blue")
plot(stats::density(ppmObs,bw = .2), main = title, cex.main = .7) +
abline(v = maxX, lty = 2, col = "red") +
abline(v = ppmEst, lty = 3, col = "blue")
plot(stats::density(ppmObs,bw = .2), main = title, cex.main = .7) +
abline(v = maxX, lty = 2, col = "red") +
abline(v = ppmEst, lty = 3, col = "blue")
legend("topright",
legend = c(paste("score > 1:", signif(maxX,digits = 3)),
paste("ppm estimate:", signif(ppmEst,digits = 3))),
col = c("red","blue"),
lty = c(2,3),cex = .7)
maxX
plot(stats::density(ppmObs,bw = .2), main = title, cex.main = .7) +
abline(v = maxX, lty = 2, col = "red") +
abline(v = ppmEst, lty = 3, col = "blue")
legend("topright",
legend = c(paste("score > 1:", signif(maxX,digits = 3)),
paste("ppm estimate:", signif(ppmEst,digits = 3))),
col = c("red","blue"),
lty = c(2,3),cex = .7)
plot(stats::density(ppmObs,bw = .2), main = title, cex.main = .7) +
abline(v = maxX, lty = 2, col = "red") +
abline(v = ppmEst, lty = 3, col = "blue")
plot(stats::density(ppmObs,bw = .2), main = title, cex.main = .7) +
abline(v = maxX, lty = 2, col = "red") +
abline(v = ppmEst, lty = 3, col = "blue")
ppmObs
ppmEst
maxX
ppmObs
title <- paste(filename, 'ppm distribution:',
signif(observedPeak$start, digits = 4),
"-",
signif(observedPeak$end, digits = 4))
plot(stats::density(ppmObs,bw = .2), main = title, cex.main = .7) +
abline(v = maxX, lty = 2, col = "red") +
abline(v = ppmEst, lty = 3, col = "blue")
plot(stats::density(ppmObs,bw = .1), main = title, cex.main = .7) +
abline(v = maxX, lty = 2, col = "red") +
abline(v = ppmEst, lty = 3, col = "blue")
legend("topright",
legend = c(paste("score > 1:", signif(maxX,digits = 3)),
paste("ppm estimate:", signif(ppmEst,digits = 3))),
col = c("red","blue"),
lty = c(2,3),cex = .7)
plot(stats::density(ppmObs,bw = 091), main = title, cex.main = .7) +
abline(v = maxX, lty = 2, col = "red") +
abline(v = ppmEst, lty = 3, col = "blue")
plot(stats::density(ppmObs,bw = 0.09), main = title, cex.main = .7) +
abline(v = maxX, lty = 2, col = "red") +
abline(v = ppmEst, lty = 3, col = "blue")
plot(stats::density(ppmObs,bw = 0.05), main = title, cex.main = .7) +
abline(v = maxX, lty = 2, col = "red") +
abline(v = ppmEst, lty = 3, col = "blue")
legend("topright",
legend = c(paste("score > 1:", signif(maxX,digits = 3)),
paste("ppm estimate:", signif(ppmEst,digits = 3))),
col = c("red","blue"),
lty = c(2,3),cex = .7)
plotDir
plotDir <- "."
title
output <- file.path(plotDir,paste0(gsub(" ", "_", title), ".pdf"))
output
title <- paste(filename, 'ppm distribution:',
signif(observedPeak$start, digits = 4),
"-",
signif(observedPeak$end, digits = 4))
output <- file.path(plotDir,paste0(gsub(" ", "_", title), ".pdf"))
output <- sub(":", "", output)
## error here...
par(mar=c(1,1,1,1))
grDevices::pdf(output, width = 8, height = 6)
plot(stats::density(ppmObs,bw = 0.05), main = title, cex.main = .7) +
abline(v = maxX, lty = 2, col = "red") +
abline(v = ppmEst, lty = 3, col = "blue")
legend("topright",
legend = c(paste("score > 1:", signif(maxX,digits = 3)),
paste("ppm estimate:", signif(ppmEst,digits = 3))),
col = c("red","blue"),
lty = c(2,3),cex = .7)
grDevices::dev.off()
plot(stats::density(ppmObs,bw = 0.1), main = title, cex.main = .7) +
abline(v = maxX, lty = 2, col = "red") +
abline(v = ppmEst, lty = 3, col = "blue")
legend("topright",
legend = c(paste("score > 1:", signif(maxX,digits = 3)),
paste("ppm estimate:", signif(ppmEst,digits = 3))),
col = c("red","blue"),
lty = c(2,3),cex = .7)
plot(stats::density(ppmObs,bw = 0.1), main = title,
cex.main = 1, cex.labs = .12) +
abline(v = maxX, lty = 2, col = "red") +
abline(v = ppmEst, lty = 3, col = "blue")
?plot
ppmObs
plot(stats::density(ppmObs,bw = 0.1), main = title,
cex.main = 1, cex.lab = 1.1) +
abline(v = maxX, lty = 2, col = "red") +
abline(v = ppmEst, lty = 3, col = "blue")
plot(stats::density(ppmObs,bw = 0.1),
main = title,
cex.main = 1, cex.lab = 1.1) +
abline(v = maxX, lty = 2, col = "red") +
abline(v = ppmEst, lty = 3, col = "blue")
plot(stats::density(ppmObs,bw = 0.1),
main = title,
cex.main = 1, cex.lab = 1.1) #+
plot(stats::density(ppmObs,bw = 0.1),
main = title,
cex.main = 1, cex.lab = 1.1) #+
grDevices::dev.off()
plot(stats::density(ppmObs,bw = 0.1),
main = title,
cex.main = 1, cex.lab = 1.1) #+
plot(stats::density(ppmObs,bw = 0.1),
main = title,
cex.main = 1, cex.lab = 1.3) #+
plot(stats::density(ppmObs,bw = 0.1),
main = title,
cex.main = 1, cex.lab = 1.3, cex.axis = 1.2) #+
plot(stats::density(ppmObs,bw = 0.1),
main = title,
cex.main = 1.4, cex.lab = 1.3, cex.axis = 1.2) #+
plot(stats::density(ppmObs,bw = 0.1),
main = title,
cex.main = 1.2, cex.lab = 1.3, cex.axis = 1.2) #+
par(mar=c(1,1,1,1))
grDevices::pdf(output, width = 8, height = 6)
## adding heuristic here to make ploting easier to see
if(length(ppmObs) < 300) {
bw <- .1
} else {
bw <- .5
}
plot(stats::density(ppmObs,bw = bw),
main = title,
cex.main = 1.2, cex.lab = 1.3, cex.axis = 1.2) #+
abline(v = maxX, lty = 2, col = "red") +
abline(v = ppmEst, lty = 3, col = "blue")
legend("topright",
legend = c(paste("score > 1:", signif(maxX,digits = 3)),
paste("ppm estimate:", signif(ppmEst,digits = 3))),
col = c("red","blue"),
lty = c(2,3),cex = .7)
grDevices::dev.off()
legend("topright",
legend = c(paste("score > 1:", signif(maxX,digits = 3)),
paste("ppm estimate:", signif(ppmEst,digits = 3))),
col = c("red","blue"),
lty = c(2,3),cex = 1)
legend("topright",
legend = c(paste("score > 1:", signif(maxX,digits = 3)),
paste("ppm estimate:", signif(ppmEst,digits = 3))),
col = c("red","blue"),
lty = c(2,3),cex = 1.1)
par(mar=c(1,1,1,1))
grDevices::pdf(output, width = 8, height = 6)
## adding heuristic here to make ploting easier to see
if(length(ppmObs) < 300) {
bw <- .1
} else {
bw <- .5
}
plot(stats::density(ppmObs,bw = bw),
main = title,
cex.main = 1.2, cex.lab = 1.3, cex.axis = 1.2) #+
abline(v = maxX, lty = 2, col = "red") +
abline(v = ppmEst, lty = 3, col = "blue")
legend("topright",
legend = c(paste("score > 1:", signif(maxX,digits = 3)),
paste("ppm estimate:", signif(ppmEst,digits = 3))),
col = c("red","blue"),
lty = c(2,3),cex = 1.1)
grDevices::dev.off()
library(xcms)
CentWaveParam()
?CentWaveParam
library(Autotuner)
library(Autotuner)
Autotuner <- readRDS(system.file("inst/extdata/Autotuner.rds", package="Autotuner"))
Autotuner <- readRDS(system.file("inst/Autotuner.rds", package="Autotuner"))
system.file("Autotuner.rds", package="Autotuner")
system.file(package = "Autotuner")
Autotuner <- readRDS(system.file("extdata/Autotuner.rds", package="Autotuner"))
Autotuner
system.file('extdata/eicParamEsts.rds', package = "Autotuner")
library(Autotuner)
Sys.which("pdflatex")
Sys.getenv(“PATH”)
Sys.getenv('“'PATH')
Sys.getenv('PATH')
Sys.setenv(PATH=paste(Sys.getenv("PATH"),"/usr/texbin",sep=":"))
Sys.which("pdflatex")
library(Autotuner)
library(devtools)
if(!require("mmetspData")) {
install_github("crmclean/mmetspData")
library(mmetspData)
}
lag <- 30
threshold<- 3.5
influence <- 0.3
signals <- lapply(getAutoIntensity(Autotuner),
ThresholdingAlgo, lag, threshold, influence)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(Autotuner)
library(devtools)
if(!require("mmetspData")) {
install_github("crmclean/mmetspData")
library(mmetspData)
}
mmetspFiles <- c(system.file("mzMLs/mtab_mmetsp_ft_120815_24.mzML", package = "mmetspData"),
system.file("mzMLs/mtab_mmetsp_ft_120815_25.mzML", package = "mmetspData"),
system.file("mzMLs/mtab_mmetsp_ft_120815_26.mzML", package = "mmetspData"))
print(basename(mmetspFiles))
metadata <- read.csv(system.file("mmetsp_metadata.csv", package = "mmetspData"),
stringsAsFactors = F)
metadata <- metadata[metadata$File.Name %in%
sub(pattern = ".mzML", "",basename(mmetspFiles)),]
print(metadata)
Autotuner <- createAutotuner(mmetspFiles,
metadata,
file_col = "File.Name",
factorCol = "Sample.Type")
influence <- 0.2
signals <- lapply(getAutoIntensity(Autotuner),
ThresholdingAlgo, lag, threshold, influence)
plot_signals(Autotuner,
threshold,
## index for which data files should be displayed
sample_index = 1:3,
signals = signals)
rm(lag, influence, threshold)
lag <- 25
threshold<- 3.5
influence <- 0.2
signals <- lapply(getAutoIntensity(Autotuner),
ThresholdingAlgo, lag, threshold, influence)
plot_signals(Autotuner,
threshold,
## index for which data files should be displayed
sample_index = 1:3,
signals = signals)
rm(lag, influence, threshold)
lag <- 25
threshold<- 3.5
influence <- 0.1
signals <- lapply(getAutoIntensity(Autotuner),
ThresholdingAlgo, lag, threshold, influence)
plot_signals(Autotuner,
threshold,
## index for which data files should be displayed
sample_index = 1:3,
signals = signals)
rm(lag, influence, threshold)
lag <- 25
threshold<- 3.1
influence <- 0.1
signals <- lapply(getAutoIntensity(Autotuner),
ThresholdingAlgo, lag, threshold, influence)
plot_signals(Autotuner,
threshold,
## index for which data files should be displayed
sample_index = 1:3,
signals = signals)
rm(lag, influence, threshold)
Autotuner <- isolatePeaks(Autotuner, returned_peaks = 10, signals)
for(i in unique(peak_difference$index)) {
plot_peaks(Autotuner = Autotuner,
boundary = 100,
peak = i)
}
for(i in unique(peak_difference$index)) {
plot_peaks(Autotuner = Autotuner,
boundary = 100,
peak = i)
}
peak_difference$index
peak_difference
signals
Autotuner
for(i in unique(Autotuner@peak_difference)) {
plot_peaks(Autotuner = Autotuner,
boundary = 100,
peak = i)
}
for(i in 1:5) {
plot_peaks(Autotuner = Autotuner,
boundary = 100,
peak = i)
}
## error with peak width estimation
## idea - filter things by mass. smaler masses are more likely to be random assosications
eicParamEsts <- EICparams(Autotuner = Autotuner,
massThresh = .005,
verbose = F,
returnPpmPlots = F,
useGap = T)
returnParams(eicParamEsts, Autotuner)
returnParams(eicParamEsts, Autotuner)
suppressWarnings(library(Autotuner))
library(Autotuner)
library(devtools)
if(!require("mmetspData")) {
install_github("crmclean/mmetspData")
library(mmetspData)
}
library(png)
library(grid)
img <- readPNG("autotuner_schematic_final.png")
grid.raster(img)
grid.raster(img)
unlink('vignettes/Intro_cache', recursive = TRUE)
knit_with_parameters('~/MIT/Research/Autotuner/vignettes/Intro.Rmd')
sessionInfo()
