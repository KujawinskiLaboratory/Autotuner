scans = allScansInData)
upperBound <- checkTable$endMatch[massIndex]
}
peakBounds[[massIndex]] <- c(lowerBound, upperBound,
total = (upperBound - lowerBound))
}
}
peakBounds
peakBounds <- list()
for(massIndex in seq_along(checkVals)) {
mass <- checkVals[massIndex]
# case 1 - the peak ends at both boundaries -----------------------
if(length(checkBoundaries) == 2) {
upperBound <- checkBounds(mass = mass,
mzDb = mzDb,
currentIndex = filteredRange[2],
ppmEst = ppmEst,
scans = allScansInData,
origBound = filteredRange[2],
header = header)
names(upperBound) <- "upper_bound"
lowerBound <- checkBounds(mass = mass,
upper = F,
mzDb = mzDb,
currentIndex = filteredRange[1],
ppmEst = ppmEst,
scans = allScansInData,
origBound = filteredRange[1],
header = header)
names(lowerBound) <- "lower_bound"
peakBounds[[massIndex]] <- data.frame(lowerBound,
upperBound,
total = (upperBound - lowerBound))
} else {
# the peak is observed a single boundary -------------------------
# Case 1 - the peak is only bounded above ---------------------
if(which(checkBoundaries) == 2) {
upperBound <- checkBounds(mass,
mzDb = mzDb,
currentIndex = filteredRange[2],
ppmEst = ppmEst,
header = header,
origBound = filteredRange[2],
scans = allScansInData)
lowerBound <- checkTable$startMatch[massIndex]
## case 2 - it is bounded from below
} else {
# Case 2 - the peak is only bounded below ---------------------
lowerBound <- checkBounds(mass,
upper = F,
mzDb = mzDb,
currentIndex = filteredRange[1],
ppmEst = ppmEst,
header = header,
origBound = filteredRange[1],
scans = allScansInData)
upperBound <- checkTable$endMatch[massIndex]
}
peakBounds[[massIndex]] <- data.frame(lowerBound,
upperBound,
total = (upperBound - lowerBound))
}
}
peakBounds
checkVals
names(peakBounds) <- checkVals
Reduce(rbind peakBounds)
peakBounds <- Reduce(rbind, peakBounds)
peakBounds
checkVals[massIndex]
checkBoundaries
length(checkBoundaries) == 2
peakBounds <- list()
for(massIndex in seq_along(checkVals)) {
mass <- checkVals[massIndex]
# case 1 - the peak ends at both boundaries -----------------------
if(length(checkBoundaries) == 2) {
upperBound <- checkBounds(mass = mass,
mzDb = mzDb,
currentIndex = filteredRange[2],
ppmEst = ppmEst,
scans = allScansInData,
origBound = filteredRange[2],
header = header)
names(upperBound) <- "upper_bound"
lowerBound <- checkBounds(mass = mass,
upper = F,
mzDb = mzDb,
currentIndex = filteredRange[1],
ppmEst = ppmEst,
scans = allScansInData,
origBound = filteredRange[1],
header = header)
names(lowerBound) <- "lower_bound"
peakBounds[[massIndex]] <- data.frame(lowerBound,
upperBound,
total = (upperBound - lowerBound),
checkBounds = 2)
} else {
# the peak is observed a single boundary -------------------------
# Case 1 - the peak is only bounded above ---------------------
if(which(checkBoundaries) == 2) {
upperBound <- checkBounds(mass,
mzDb = mzDb,
currentIndex = filteredRange[2],
ppmEst = ppmEst,
header = header,
origBound = filteredRange[2],
scans = allScansInData)
lowerBound <- checkTable$startMatch[massIndex]
## case 2 - it is bounded from below
} else {
# Case 2 - the peak is only bounded below ---------------------
lowerBound <- checkBounds(mass,
upper = F,
mzDb = mzDb,
currentIndex = filteredRange[1],
ppmEst = ppmEst,
header = header,
origBound = filteredRange[1],
scans = allScansInData)
upperBound <- checkTable$endMatch[massIndex]
}
peakBounds[[massIndex]] <- data.frame(lowerBound,
upperBound,
total = (upperBound - lowerBound),
checkBounds = 1)
}
}
peakBounds
peakBounds <- Reduce(rbind, peakBounds)
names(peakBounds) <- checkVals
peakBounds
boundTemp <- peakBounds[peakBounds$checkBounds == 2]
boundTemp <- peakBounds[peakBounds$checkBounds == 2,]
boundTemp
boundTemp$total
boxStat <- boxplot(boundTemp$total)
?boxplot
boxStat <- boxplot(boundTemp$total, plot = F)
boxStat
boxStat$out
boundTemp$total %in% boxStat$out
boundTemp[!(boundTemp$total %in% boxStat$out),]
checkVals
peakBounds
peakBounds <- boundTemp[!(boundTemp$total %in% boxStat$out),]
rm(boundTemp, boxStat)
peakBounds
peakBounds
peakBounds
peakBounds$range <- peakBounds$upperBound - peakBounds$lowerBound
peakBounds
peakBounds$total
which.max(peakBounds$total)
peakBounds[which.max(peakBounds$total),][1]
which.max(peakBounds$total)
peakBounds[which.max(peakBounds$total)[1],]
checkThisBound <- peakBounds[which.max(peakBounds$total)[1],]
rtUpper <- header$retentionTime[grep(paste0("scan=","\\b",
checkThisBound$upperBound,
"\\b"),
header$spectrumId)]
rtLower <- header$retentionTime[grep(paste0("scan=","\\b",
checkThisBound$lowerBound,
"\\b"),
header$spectrumId)]
rtLower
maxPw <- rtUpper - rtLower
maxPw
source('~/MIT/Research/Autotuner/R/findPeakWidth.R', echo=TRUE)
### peakWidth Estimate
maxPw <- findPeakWidth(approvScorePeaks = approvScorePeaks,
mzDb = mzDb,
header = header,
sortedAllEIC = sortedAllEIC,
boundaries = boundaries,
ppmEst = ppmEst)
maxPw
library(Autotuner)
library(Autotuner)
library(devtools)
if(!require("mmetspData")) {
install_github("crmclean/mmetspData")
library(mmetspData)
}
eicParamEsts <- EICparams(Autotuner = Autotuner,
massThresh = .005,
peak_table = peak_table,
verbose = F,
returnPpmPlots = F,
useGap = T)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(Autotuner)
library(devtools)
if(!require("mmetspData")) {
install_github("crmclean/mmetspData")
library(mmetspData)
}
mmetspFiles <- c(system.file("mzMLs/mtab_mmetsp_ft_120815_24.mzML", package = "mmetspData"),
system.file("mzMLs/mtab_mmetsp_ft_120815_25.mzML", package = "mmetspData"),
system.file("mzMLs/mtab_mmetsp_ft_120815_26.mzML", package = "mmetspData"))
print(basename(mmetspFiles))
metadata <- read.csv(system.file("mmetsp_metadata.csv", package = "mmetspData"),
stringsAsFactors = F)
metadata <- metadata[metadata$File.Name %in%
sub(pattern = ".mzML", "",basename(mmetspFiles)),]
print(metadata)
Autotuner <- createAutotuner(mmetspFiles,
metadata,
file_col = "File.Name",
factorCol = "Sample.Type")
lag <- 30
threshold<- 3.5
influence <- 0.3
signals <- lapply(getAutoIntensity(Autotuner),
ThresholdingAlgo, lag, threshold, influence)
plot_signals(Autotuner,
threshold,
## index for which data files should be displayed
sample_index = 1:3,
signals = signals)
rm(lag, influence, threshold)
## make these methods into internals
peaks <- extract_peaks(Autotuner = Autotuner,
returned_peaks = 10,
signals = signals)
peak_table <- peakwidth_table(Autotuner = Autotuner,
peakList = peaks,
returned_peaks = 7)
peak_difference <- peak_time_difference(peak_table)
for(i in unique(peak_difference$index)) {
plot_peaks(Autotuner = Autotuner,
boundary = 100,
peak = i,
peak_table = peak_table,
peak_difference = peak_difference)
}
eicParamEsts <- EICparams(Autotuner = Autotuner,
massThresh = .005,
peak_table = peak_table,
verbose = F,
returnPpmPlots = F,
useGap = T)
eicParamEsts
params <- TIC_params(peak_table, peak_difference)
colNameCheck <- all(c("ppm", "peakCount", "noiseThreshold", "prefilterI", "prefilterScan",
"TenPercentQuanSN","maxPw", "minPw") %in% colnames(eicParamEsts))
assertthat::assert_that(colNameCheck,
msg = "Error in EICparams: some of the column names from the output are missing. Cannot complete parameter estimation.")
ppmEst <- weighted.mean(eicParamEsts$ppm, eicParamEsts$peakCount)
noiseEst <- min(eicParamEsts$noiseThreshold, na.rm = T)
prefilterIEst <- min(eicParamEsts$prefilterI, na.rm = T)
prefilterScanEst <- min(eicParamEsts$prefilterScan, na.rm = T)
snEst <- min(eicParamEsts$TenPercentQuanSN, na.rm = T)
maxPw <- split(eicParamEsts$maxPw, eicParamEsts$sampleID)
maxPw <- sapply(maxPw, max)
maxPw <- mean(maxPw)
maxPw
maxPw <- split(eicParamEsts$maxPw, eicParamEsts$sampleID)
maxPw
roxygen2::roxygenize()
peaks
library(Autotuner)
## make these methods into internals
isolatePeaks <- function(Autotuner, returned_peaks, signals) {
Autotuner@peaks <- extract_peaks(Autotuner,
returned_peaks,
signals)
Autotuner@peak_table <- peakwidth_table(Autotuner,
returned_peaks = 7)
Autotuner@peak_difference <- peak_time_difference(Autotuner@peak_table)
return(Autotuner)
}
library(Autotuner)
library(devtools)
if(!require("mmetspData")) {
install_github("crmclean/mmetspData")
library(mmetspData)
}
Autotuner <- isolatePeaks(Autotuner, returned_peaks = 10, signals)
Autotuner@peak_table <- peakwidth_table(Autotuner,
returned_peaks = 7)
library(Autotuner)
Autotuner@peak_table <- peakwidth_table(Autotuner,
returned_peaks = 7)
source('~/MIT/Research/Autotuner/R/peakwidth_table.R', echo=TRUE)
library(Autotuner)
library(devtools)
if(!require("mmetspData")) {
install_github("crmclean/mmetspData")
library(mmetspData)
}
Autotuner@peak_table <- peakwidth_table(Autotuner,
returned_peaks = 7)
Autotuner@peaks <- extract_peaks(Autotuner,
returned_peaks,
signals)
returned_peaks = 10
Autotuner@peaks <- extract_peaks(Autotuner,
returned_peaks,
signals)
Autotuner@peak_table <- peakwidth_table(Autotuner, returned_peaks)
## make these methods into internals
isolatePeaks <- function(Autotuner, returned_peaks, signals) {
Autotuner@peaks <- extract_peaks(Autotuner,
returned_peaks,
signals)
Autotuner@peak_table <- peakwidth_table(Autotuner, returned_peaks)
Autotuner@peak_difference <- peak_time_difference(Autotuner@peak_table)
return(Autotuner)
}
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(Autotuner)
library(devtools)
if(!require("mmetspData")) {
install_github("crmclean/mmetspData")
library(mmetspData)
}
mmetspFiles <- c(system.file("mzMLs/mtab_mmetsp_ft_120815_24.mzML", package = "mmetspData"),
system.file("mzMLs/mtab_mmetsp_ft_120815_25.mzML", package = "mmetspData"),
system.file("mzMLs/mtab_mmetsp_ft_120815_26.mzML", package = "mmetspData"))
print(basename(mmetspFiles))
metadata <- read.csv(system.file("mmetsp_metadata.csv", package = "mmetspData"),
stringsAsFactors = F)
metadata <- metadata[metadata$File.Name %in%
sub(pattern = ".mzML", "",basename(mmetspFiles)),]
print(metadata)
Autotuner <- createAutotuner(mmetspFiles,
metadata,
file_col = "File.Name",
factorCol = "Sample.Type")
lag <- 30
threshold<- 3.5
influence <- 0.3
signals <- lapply(getAutoIntensity(Autotuner),
ThresholdingAlgo, lag, threshold, influence)
plot_signals(Autotuner,
threshold,
## index for which data files should be displayed
sample_index = 1:3,
signals = signals)
rm(lag, influence, threshold)
## make these methods into internals
isolatePeaks <- function(Autotuner, returned_peaks, signals) {
Autotuner@peaks <- extract_peaks(Autotuner,
returned_peaks,
signals)
Autotuner@peak_table <- peakwidth_table(Autotuner, returned_peaks)
Autotuner@peak_difference <- peak_time_difference(Autotuner@peak_table)
return(Autotuner)
}
Autotuner <- isolatePeaks(Autotuner, returned_peaks = 10, signals)
library(Autotuner)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(Autotuner)
library(devtools)
if(!require("mmetspData")) {
install_github("crmclean/mmetspData")
library(mmetspData)
}
Autotuner <- isolatePeaks(Autotuner, returned_peaks = 10, signals)
Autotuner
peakwidth_table
args(peakwidth_table)
source('~/MIT/Research/Autotuner/tests/testthat/test_loadingData.R', echo=TRUE)
source('~/MIT/Research/Autotuner/tests/testthat/test_loadingData.R', echo=TRUE)
source('~/MIT/Research/Autotuner/R/isolatePeaks.R', echo=TRUE)
## make these methods into internals
Autotuner <- isolatePeaks(Autotuner, returned_peaks = 10, signals)
roxygen2::roxygenize()
returnParams <- function(eicParamEsts, Autotuner) {
params <- TIC_params(Autotuner@peak_table, Autotuner@peak_difference)
colNameCheck <- all(c("ppm", "peakCount",
"noiseThreshold", "prefilterI",
"prefilterScan",
"TenPercentQuanSN","maxPw", "minPw") %in% colnames(eicParamEsts))
assertthat::assert_that(colNameCheck,
msg = "Error in EICparams: some of the column names from the output are missing. Cannot complete parameter estimation.")
ppmEst <- weighted.mean(eicParamEsts$ppm, eicParamEsts$peakCount)
noiseEst <- min(eicParamEsts$noiseThreshold, na.rm = T)
prefilterIEst <- min(eicParamEsts$prefilterI, na.rm = T)
prefilterScanEst <- min(eicParamEsts$prefilterScan, na.rm = T)
snEst <- min(eicParamEsts$TenPercentQuanSN, na.rm = T)
maxPw <- split(eicParamEsts$maxPw, eicParamEsts$sampleID)
maxPw <- sapply(maxPw, max)
maxPw <- mean(maxPw)
minPw <- min(eicParamEsts$minPw)
estimates <- c(ppm = ppmEst,
noise = noiseEst,
preIntensity = prefilterIEst,
preScan = prefilterScanEst,
snThresh = snEst,
"Max Peakwidth" = maxPw,
"Min Peakwidth" = minPw)
rm(ppmEst,noiseEst,prefilterIEst,prefilterScanEst,snEst,maxPw,minPw)
ppmSd <- sd(eicParamEsts$ppm)
noiseSd <- sd(eicParamEsts$noiseThreshold)
prefilSd <- sd(eicParamEsts$prefilterI, na.rm = T)
prefilScanSd <- sd(eicParamEsts$prefilterScan, na.rm = T)
snEstSd <- sd(eicParamEsts$TenPercentQuanSN, na.rm = T)
maxPwDist <- abs(diff(sort(eicParamEsts$maxPw, decreasing = T))[1])
minPwDist <- abs(diff(sort(eicParamEsts$minPw, decreasing = T))[2])
variability <- c(ppmSd, noiseSd, prefilSd, prefilScanSd, snEstSd,
maxPwDist,
minPwDist)
rm(ppmSd, noiseSd, prefilSd, prefilScanSd, snEstSd, maxPwDist, minPwDist)
description <- c("Standard Deviation of all PPM Estimates",
"Standard Deviation of all noise Estimates",
'Standard Deviation of all prefileter Intensity Estimates',
"Standard Deviation of all scan coung Estimates",
"Standard Deviation of all s/n threshold Estimates",
"Distance between two highest estimated peak widths",
"Distance between two lowest estimated peak widths")
aggregatedEstimates <- data.frame(Parameters = names(estimates),
estimates = signif(estimates,
digits = 4),
'Variability Measure' = signif(variability,
digits = 4),
"Measure" = description)
return(aggregatedEstimates)
}
returnParams(eicParamEsts, Autotuner)
eicParamEsts <- EICparams(Autotuner = Autotuner,
massThresh = .005,
peak_table = peak_table,
verbose = F,
returnPpmPlots = F,
useGap = T)
eicParamEsts <- EICparams(Autotuner = Autotuner,
massThresh = .005,
peak_table = peak_table,
verbose = F,
returnPpmPlots = F,
useGap = T)
returnParams <- function(eicParamEsts, Autotuner) {
params <- TIC_params(Autotuner@peak_table, Autotuner@peak_difference)
colNameCheck <- all(c("ppm", "peakCount",
"noiseThreshold", "prefilterI",
"prefilterScan",
"TenPercentQuanSN","maxPw", "minPw") %in% colnames(eicParamEsts))
assertthat::assert_that(colNameCheck,
msg = "Error in EICparams: some of the column names from the output are missing. Cannot complete parameter estimation.")
ppmEst <- weighted.mean(eicParamEsts$ppm, eicParamEsts$peakCount)
noiseEst <- min(eicParamEsts$noiseThreshold, na.rm = T)
prefilterIEst <- min(eicParamEsts$prefilterI, na.rm = T)
prefilterScanEst <- min(eicParamEsts$prefilterScan, na.rm = T)
snEst <- min(eicParamEsts$TenPercentQuanSN, na.rm = T)
maxPw <- split(eicParamEsts$maxPw, eicParamEsts$sampleID)
maxPw <- sapply(maxPw, max)
maxPw <- mean(maxPw)
minPw <- min(eicParamEsts$minPw)
estimates <- c(ppm = ppmEst,
noise = noiseEst,
preIntensity = prefilterIEst,
preScan = prefilterScanEst,
snThresh = snEst,
"Max Peakwidth" = maxPw,
"Min Peakwidth" = minPw)
rm(ppmEst,noiseEst,prefilterIEst,prefilterScanEst,snEst,maxPw,minPw)
ppmSd <- sd(eicParamEsts$ppm)
noiseSd <- sd(eicParamEsts$noiseThreshold)
prefilSd <- sd(eicParamEsts$prefilterI, na.rm = T)
prefilScanSd <- sd(eicParamEsts$prefilterScan, na.rm = T)
snEstSd <- sd(eicParamEsts$TenPercentQuanSN, na.rm = T)
maxPwDist <- abs(diff(sort(eicParamEsts$maxPw, decreasing = T))[1])
minPwDist <- abs(diff(sort(eicParamEsts$minPw, decreasing = T))[2])
variability <- c(ppmSd, noiseSd, prefilSd, prefilScanSd, snEstSd,
maxPwDist,
minPwDist)
rm(ppmSd, noiseSd, prefilSd, prefilScanSd, snEstSd, maxPwDist, minPwDist)
description <- c("Standard Deviation of all PPM Estimates",
"Standard Deviation of all noise Estimates",
'Standard Deviation of all prefileter Intensity Estimates',
"Standard Deviation of all scan coung Estimates",
"Standard Deviation of all s/n threshold Estimates",
"Distance between two highest estimated peak widths",
"Distance between two lowest estimated peak widths")
aggregatedEstimates <- data.frame(Parameters = names(estimates),
estimates = signif(estimates,
digits = 4),
'Variability Measure' = signif(variability,
digits = 4),
"Measure" = description)
return(aggregatedEstimates)
}
returnParams(eicParamEsts, Autotuner)
eicParamEsts
library(Autotuner)
eicParamEsts <- EICparams(Autotuner = Autotuner,
massThresh = .005,
peak_table = peak_table,
verbose = F,
returnPpmPlots = F,
useGap = T)
library(Autotuner)
library(devtools)
if(!require("mmetspData")) {
install_github("crmclean/mmetspData")
library(mmetspData)
}
eicParamEsts <- EICparams(Autotuner = Autotuner,
eicParamEsts
