for(curPeak in 1:nrow(currentTable)) {
start <- currentTable[curPeak,"Start_time"]
end <- currentTable[curPeak,"End_time"]
width <- currentTable$peak_width[curPeak]
observedPeak <- list(start = start, end = end)
## currently here
estimatedPeakParams <- checkEICPeaks(currentMsFile = currentMsFile,
observedPeak = observedPeak,
massThresh)
if(is.null(estimatedPeakParams)) {
next
}
pickedParams[[curPeak]] <- cbind(estimatedPeakParams,
startTime = start,
endTime = end,
sampleID = j)
}
pickedParams
sampleParams <- Reduce(rbind, pickedParams)
sampleParams
weighted.mean(sampleParams$ppm, sampleParams$peakCount)
curPeak <- 6
start <- currentTable[curPeak,"Start_time"]
end <- currentTable[curPeak,"End_time"]
width <- currentTable$peak_width[curPeak]
observedPeak <- list(start = start, end = end)
# extracting ms1 information for current peak -----------------------------
suppressWarnings(rm(no_match,approvedPeaks))
sampleChrom <- mzR::header(currentMsFile)
scanDiff <- diff(sampleChrom$retentionTime[sampleChrom$msLevel == 1L])
rate <- mean(scanDiff)
rm(scanDiff)
sortedAllEIC <- dissectScans(currentMsFile, observedPeak, sampleChrom)
assertthat::assert_that(nrow(sortedAllEIC) > 0,
msg = "Check dissectScans within checkEICPeaks. A table with 0 rows was returned. Make sure correct TIC peaks were selected.")
boundaries <- range(sortedAllEIC$dataMatchIndex)
# Checking if sorted scans pass mz error threshold ------------------------
matchedMasses <- rle(diff(sortedAllEIC$mz) < massThresh)
noiseAndPeaks <- filterPeaksfromNoise(matchedMasses)
no_match <- noiseAndPeaks[[1]]
truePeaks <- noiseAndPeaks[[2]]
rm(noiseAndPeaks)
approvedPeaks <- findTruePeaks(truePeaks, sortedAllEIC)
if(nrow(approvedPeaks) == 0) {
message("No observed m/z value met was observed across adjacent scans below an error of massThresh.")
return(NULL)
}
# Filtering data by variability and ppm checks ----------------------------
ppmEst <- filterPpmError(approvedPeaks)
ppmEst
ppmObs <- approvedPeaks$meanPPM
ppmObs <- strsplit(split = ";", x = as.character(ppmObs)) %>%
sapply(as.numeric) %>%
unlist()
totalPPM <- length(ppmObs)
## estimating clustering based on hard coded 80% Vexp threshold
clustCount <- 1
varExp <- 0
gapStat <- cluster::clusGap(x = as.matrix(ppmObs),
FUNcluster = kmeans,
K.max = 10,
B = 10,
verbose = F)
gapStat <- gapStat$Tab[-1,]
clusters <- min(which(diff(-gapStat[,3]) > 0)) + 1
kmeansPPM <- kmeans(ppmObs, clusters)
kmeansPPM
gapStat
diff(-gapStat[,3]) > 0)
diff(-gapStat[,3]) > 0)
-gapStat[,3]
diff(-gapStat[,3])
gapStat[,3]
diff(gapStat[,3])
gapStat
clusters <- 3
kmeansPPM <- kmeans(ppmObs, clusters)
kmeansPPM
gapStat
gapStat <- cluster::clusGap(x = as.matrix(ppmObs),
FUNcluster = kmeans,
K.max = 10,
B = 10,
verbose = F)
gapStat <- gapStat$Tab[-1,]
clusters <- min(which(diff(gapStat[,3]) > 0)) + 1
kmeansPPM <- kmeans(ppmObs, clusters)
message(clusters)
## estimating clustering based on hard coded 80% Vexp threshold
clustCount <- 1
varExp <- 0
gapStat <- cluster::clusGap(x = as.matrix(ppmObs),
FUNcluster = kmeans,
K.max = 10,
B = 10,
verbose = F)
gapStat <- gapStat$Tab[-1,]
clusters <- min(which(diff(gapStat[,3]) > 0)) + 1
kmeansPPM <- kmeans(ppmObs, clusters)
message(clusters)
## cluster which contains smallest ppm values
clusterSize <- table(kmeansPPM$cluster) %>% sort(decreasing = T)
maxCluster <- names(clusterSize)[1]
minCluster <- which(kmeansPPM$cluster == maxCluster)
rm(clusterSize)
x <- ppmObs
n <- length(x)
h <- 1
gauss <- function(x) 1/sqrt(2*pi) * exp(-(x^2)/2)
gaussDKE <- function(a, x) gauss((x - a)/h)/(n * h)
bumps <- sapply(ppmObs[minCluster], gaussDKE, x)
OutlierScore <- sapply(1:n, function(xx) {
rowSums(bumps)[xx]/(sum(rowSums(bumps))/n)
})
scoreSub <- which(OutlierScore > 1)
ppmEst <- max(ppmObs[scoreSub])
ppmEst
ppmObs[scoreSub]
mean(ppmObs[scoreSub])
ppmEst + sd(ppmObs[scoreSub])*3
ppmEst <- mean(ppmObs[scoreSub])
ppmEst <- ppmEst + sd(ppmObs[scoreSub])*3
ppmEst
clusters <- min(which(diff(gapStat[,3]) > 0))
kmeansPPM <- kmeans(ppmObs, clusters)
message(clusters)
## cluster which contains smallest ppm values
clusterSize <- table(kmeansPPM$cluster) %>% sort(decreasing = T)
maxCluster <- names(clusterSize)[1]
minCluster <- which(kmeansPPM$cluster == maxCluster)
rm(clusterSize)
x <- ppmObs
n <- length(x)
h <- 1
gauss <- function(x) 1/sqrt(2*pi) * exp(-(x^2)/2)
gaussDKE <- function(a, x) gauss((x - a)/h)/(n * h)
bumps <- sapply(ppmObs[minCluster], gaussDKE, x)
OutlierScore <- sapply(1:n, function(xx) {
rowSums(bumps)[xx]/(sum(rowSums(bumps))/n)
})
scoreSub <- which(OutlierScore > 1)
max(ppmObs[scoreSub])
ppmEst <- max(ppmObs[scoreSub])
ppmEst <- ppmEst + sd(ppmObs[scoreSub])*3
ppmEst
gapStat <- cluster::clusGap(x = as.matrix(ppmObs),
FUNcluster = kmeans,
K.max = 10,
B = 10,
verbose = F)
gapStat$Tab
gapStat <- gapStat$Tab
min(which(diff(gapStat[,3]) > 0))
which(diff(gapStat[,3]) > 0)
diff(gapStat[,3])
diff(gapStat[,3]) > 0
which(diff(gapStat[,3]) > 0)
clusters <- min(which(diff(gapStat[,3]) > 0)) + 1
kmeansPPM <- kmeans(ppmObs, clusters)
kmeansPPM
## cluster which contains smallest ppm values
clusterSize <- table(kmeansPPM$cluster) %>% sort(decreasing = T)
maxCluster <- names(clusterSize)[1]
minCluster <- which(kmeansPPM$cluster == maxCluster)
rm(clusterSize)
x <- ppmObs
n <- length(x)
h <- 1
gauss <- function(x) 1/sqrt(2*pi) * exp(-(x^2)/2)
gaussDKE <- function(a, x) gauss((x - a)/h)/(n * h)
bumps <- sapply(ppmObs[minCluster], gaussDKE, x)
OutlierScore <- sapply(1:n, function(xx) {
rowSums(bumps)[xx]/(sum(rowSums(bumps))/n)
})
scoreSub <- which(OutlierScore > 1)
ppmEst <- max(ppmObs[scoreSub])
ppmEst <- ppmEst + sd(ppmObs[scoreSub])*3
ppmEst
source('~/MIT/Research/Autotuner/R/checkEICFunctions.R', echo=TRUE)
curPeak
curPeak <- 1
start <- currentTable[curPeak,"Start_time"]
end <- currentTable[curPeak,"End_time"]
width <- currentTable$peak_width[curPeak]
observedPeak <- list(start = start, end = end)
# extracting ms1 information for current peak -----------------------------
suppressWarnings(rm(no_match,approvedPeaks))
sampleChrom <- mzR::header(currentMsFile)
scanDiff <- diff(sampleChrom$retentionTime[sampleChrom$msLevel == 1L])
rate <- mean(scanDiff)
rm(scanDiff)
sortedAllEIC <- dissectScans(currentMsFile, observedPeak, sampleChrom)
assertthat::assert_that(nrow(sortedAllEIC) > 0,
msg = "Check dissectScans within checkEICPeaks. A table with 0 rows was returned. Make sure correct TIC peaks were selected.")
boundaries <- range(sortedAllEIC$dataMatchIndex)
# Checking if sorted scans pass mz error threshold ------------------------
matchedMasses <- rle(diff(sortedAllEIC$mz) < massThresh)
noiseAndPeaks <- filterPeaksfromNoise(matchedMasses)
no_match <- noiseAndPeaks[[1]]
truePeaks <- noiseAndPeaks[[2]]
rm(noiseAndPeaks)
approvedPeaks <- findTruePeaks(truePeaks, sortedAllEIC)
if(nrow(approvedPeaks) == 0) {
message("No observed m/z value met was observed across adjacent scans below an error of massThresh.")
return(NULL)
}
# Filtering data by variability and ppm checks ----------------------------
ppmEst <- filterPpmError(approvedPeaks)
ppmEst
ppmObs <- approvedPeaks$meanPPM
ppmObs <- strsplit(split = ";", x = as.character(ppmObs)) %>%
sapply(as.numeric) %>%
unlist()
totalPPM <- length(ppmObs)
## estimating clustering based on hard coded 80% Vexp threshold
clustCount <- 1
varExp <- 0
gapStat <- cluster::clusGap(x = as.matrix(ppmObs),
FUNcluster = kmeans,
K.max = 10,
B = 10,
verbose = F)
gapStat <- gapStat$Tab
gapStat
gapStat <- cluster::clusGap(x = as.matrix(ppmObs),
FUNcluster = kmeans,
K.max = 10,
B = 10,
verbose = F)
gapStat
gapStat$n
gapStat$B
gapStat$call
gapStat$spaceH0
gapStat$FUNcluster()
gapStat$call
gapStat
maxSE(gapStat)
gapStat
clusters
kmeans(ppmObs, clusters)
kmeansPPM <- kmeans(ppmObs, clusters)
## cluster which contains smallest ppm values
clusterSize <- table(kmeansPPM$cluster) %>% sort(decreasing = T)
maxCluster <- names(clusterSize)[1]
minCluster <- which(kmeansPPM$cluster == maxCluster)
rm(clusterSize)
x <- ppmObs
n <- length(x)
h <- 1
gauss <- function(x) 1/sqrt(2*pi) * exp(-(x^2)/2)
gaussDKE <- function(a, x) gauss((x - a)/h)/(n * h)
bumps <- sapply(ppmObs[minCluster], gaussDKE, x)
OutlierScore <- sapply(1:n, function(xx) {
rowSums(bumps)[xx]/(sum(rowSums(bumps))/n)
})
scoreSub <- which(OutlierScore > 1)
ppmEst <- max(ppmObs[scoreSub])
ppmEst <- ppmEst + sd(ppmObs[scoreSub])*3
ppmEst
gapStat <- cluster::clusGap(x = as.matrix(ppmObs),
FUNcluster = kmeans,
K.max = 5,
B = 10,
verbose = F)
gapStat
gapStat <- cluster::clusGap(x = as.matrix(ppmObs),
FUNcluster = kmeans,
K.max = 5,
B = 10,
verbose = F)
gapStat <- gapStat$Tab
gapStat
diff(gapStat[,3])
gapStat
gapStat[,3]
diff(gapStat[,3])
diff(-gapStat[,3])
which(diff(-gapStat[,3]) > 0)
min(which(diff(-gapStat[,3]) > 0)) + 1
clusters <- min(which(diff(-gapStat[,3]) > 0)) + 1
kmeansPPM <- kmeans(ppmObs, clusters)
kmeansPPM
kmeansPPM
source('~/MIT/Research/Autotuner/R/checkEICFunctions.R', echo=TRUE)
# going through each peak from a sample -----------------------------
pickedParams <- list()
for(curPeak in 1:nrow(currentTable)) {
start <- currentTable[curPeak,"Start_time"]
end <- currentTable[curPeak,"End_time"]
width <- currentTable$peak_width[curPeak]
observedPeak <- list(start = start, end = end)
## currently here
estimatedPeakParams <- checkEICPeaks(currentMsFile = currentMsFile,
observedPeak = observedPeak,
massThresh)
if(is.null(estimatedPeakParams)) {
next
}
pickedParams[[curPeak]] <- cbind(estimatedPeakParams,
startTime = start,
endTime = end,
sampleID = j)
}
pickedParams
sampleParams <- Reduce(rbind, pickedParams)
weighted.mean(sampleParams$ppm, sampleParams$peakCount)
## this function is autotuner
eicParamEsts <- EICparams(Autotuner = autotuner,
massThresh = .01,
peak_table = peak_table)
eicParamEsts
## checking colnames of current table
colNameCheck <- all(c("ppm", "peakCount", "noiseThreshold", "prefilterI", "prefilterScan",
"TenPercentQuanSN","maxPw", "minPw") %in% colnames(eicParamEsts))
assertthat::assert_that(colNameCheck,
msg = "Error in EICparams: some of the column names from the output are missing. Cannot complete parameter estimation.")
ppmEst <- weighted.mean(eicParamEsts$ppm, eicParamEsts$peakCount)
ppmEst
noiseEst <- min(eicParamEsts$noiseThreshold, na.rm = T)
prefilterIEst <- min(eicParamEsts$prefilterI, na.rm = T)
prefilterScanEst <- min(eicParamEsts$prefilterScan, na.rm = T)
snEst <- min(eicParamEsts$TenPercentQuanSN, na.rm = T)
maxPw <- max(eicParamEsts$maxPw)
minPw <- min(eicParamEsts$maxPw)
estimates <- c(ppm = ppmEst,
noise = noiseEst,
preIntensity = prefilterIEst,
preScan = prefilterScanEst,
snThresh = snEst,
"Max Peakwidth" = maxPw,
"Min Peakwidth" = minPw)
estimates
sd(eicParamEsts$ppm)
ppmEst
ppmSd <- sd(eicParamEsts$ppm)
noiseSd <- sd(eicParamEsts$noiseThreshold)
prefilSd <- sd(eicParamEsts$prefilterI, na.rm = T)
prefilScanSd <- sd(eicParamEsts$prefilterScan, na.rm = T)
snEstSd <- sd(eicParamEsts$TenPercentQuanSN, na.rm = T)
maxPwDist <- abs(diff(sort(eicParamEsts$maxPw, decreasing = T))[1])
minPwDist <- abs(diff(sort(eicParamEsts$minPw, decreasing = T))[2])
variability <- c(ppmSd, noiseSd, prefilSd, prefilScanSd, snEstSd,
maxPwDist,
minPwDist)
rm(ppmSd, noiseSd, prefilSd, prefilScanSd, snEstSd, maxPwDist, minPwDist)
description <- c("Standard Deviation of all PPM Estimates",
"Standard Deviation of all noise Estimates",
'Standard Deviation of all prefileter Intensity Estimates',
"Standard Deviation of all scan coung Estimates",
"Standard Deviation of all s/n threshold Estimates",
"Distance between two highest estimated peak widths",
"Distance between two lowest estimated peak widths")
aggregatedEstimates <- data.frame(Parameters = names(estimates),
estimates = signif(estimates, digits = 4),
'Variability Measure' = signif(variability, digits = 4),
"Measure" = description)
aggregatedEstimates
library(Autotuner)
library(Autotuner)
sample(4, 22)
sample(40, 22)
kmeans(sample(40, 22))
kmeans(as.matrix(sample(40, 22)))
kmeans(as.matrix(sample(40, 22)))
as.matrix(sample(40, 22))
as.matrix(rnorm(40, 22))
kmeans(as.matrix(rnorm(40, 22)))
kmeans(as.matrix(rnorm(40, 22)), centers = 2)
yy<- kmeans(as.matrix(rnorm(40, 22)), centers = 2)$
## cluster which contains smallest ppm values
clusterSize <- table(kmeansPPM$cluster) %>% sort(decreasing = T)
yy<- kmeans(as.matrix(rnorm(40, 22)), centers = 2)$
yy
yy<- kmeans(as.matrix(rnorm(40, 22)), centers = 2)$
yy
## cluster which contains smallest ppm values
clusterSize <- table(kmeansPPM$cluster) %>% sort(decreasing = T)
yy<- kmeans(as.matrix(rnorm(40, 22)), centers = 2)$
yy
yy<- kmeans(as.matrix(rnorm(40, 22)), centers = 2)
yy
yy$totss
yy$iter
yy$tot.withinss
yy$centers
yy$cluster
yy$tot.withinss
yy$withinss
yy$totss
yy$ifault
yy$iter
yy
yy$tot.withinss
yy<- kmeans(as.matrix(rnorm(40, 22)), centers = 1)
yy$tot.withinss
yy<- kmeans(as.matrix(rnorm(40, 22)), centers = 10)
yy$tot.withinss
yy
yy<- kmeans(as.matrix(rnorm(40, 22)), centers = 1)
yy$tot.withinss
yy$ifault
yy$cluster
yy$totss
yy$betweenss/yy$tot.withinss
yy$betweenss/yy$tot.withinss
yy<- kmeans(as.matrix(rnorm(40, 22)), centers = 2)
yy$betweenss/yy$tot.withinss
yy<- kmeans(as.matrix(rnorm(40, 22)), centers = 4)
yy$betweenss/yy$tot.withinss
yy<- kmeans(as.matrix(rnorm(40, 22)), centers = 100)
yy$betweenss/yy$tot.withinss
yy<- kmeans(as.matrix(rnorm(40, 22)), centers = 10)
yy$betweenss/yy$tot.withinss
s.matrix(rnorm(40, 22)
as.matrix(rnorm(40, 22))
rnorm(40, 22)
source('~/MIT/Research/Autotuner/R/checkEICFunctions.R', echo=TRUE)
source('~/MIT/Research/Autotuner/R/checkEICPeaks.R', echo=TRUE)
source('~/MIT/Research/Autotuner/R/EICParams.R', echo=TRUE)
roxygen2::roxygenise()
library(Autotuner)
source('~/MIT/Research/Autotuner/R/EICParams.R', echo=TRUE)
library(Autotuner)
library(Autotuner)
library(Autotuner)
dataPaths
source('~/MIT/Research/xcmsAutotuner/scr/2019-03-25/casero_param_test.R', echo=TRUE)
library(Autotuner)
usethis::use_package("entropy")
roxygen2::roxygenise()
library(Autotuner)
library(Autotuner)
library(Autotuner)
library(Autotuner)
library(Autotuner)
library(Autotuner)
library(Autotuner)
library(Autotuner)
library(Autotuner)
library(Autotuner)
library(Autotuner)
library(Autotuner)
library(Autotuner)
library(Autotuner)
library(Autotuner)
source('~/MIT/Research/Autotuner/R/EICParams.R', echo=TRUE)
library(Autotuner)
library(Autotuner)
library(Autotuner)
library(Autotuner)
library(Autotuner)
library(Autotuner)
source('~/MIT/Research/Autotuner/R/checkEICFunctions.R', echo=TRUE)
library(Autotuner)
?sample
sample( 5000)
library(Autotuner)
sample(x = 1:length(ppmObs), n = 5000)
library(Autotuner)
library(Autotuner)
library(Autotuner)
launchAutotuner()
library(Autotuner)
library(Autotuner)
library(Autotuner)
Autotuner::findTruePeaks
Autotuner::findTruePeaks
library(Autotuner)
library(Autotuner)
library(Autotuner)
library(Autotuner)
library(Autotuner)
library(Autotuner)
roxygen2::roxygenise()
source('~/MIT/Research/Autotuner/R/checkEICFunctions.R', echo=TRUE)
usethis::use_package("cluster")
devtools::use_mit_license()
usethis::use_mit_license()
usethis::use_mit_license(name = "Craig McLean")
roxygen2::roxygenise()
library(Autotuner)
while(subsample) {
origDist <- stats::density(ppmObs, bw = 1)$y
set.seed(1)
newDist1 <-  stats::density(sample(ppmObs, checkPpm), bw = 1)$y
set.seed(2)
newDist2 <-  stats::density(sample(ppmObs, checkPpm), bw = 1)$y
set.seed(3)
newDist3 <-  stats::density(sample(ppmObs, checkPpm), bw = 1)$y
set.seed(4)
newDist4 <-  stats::density(sample(ppmObs, checkPpm), bw = 1)$y
set.seed(5)
newDist5 <-  stats::density(sample(ppmObs, checkPpm), bw = 1)$y
set.seed(6)
newDist6 <-  stats::density(sample(ppmObs, checkPpm), bw = 1)$y
set.seed(7)
newDist7 <-  stats::density(sample(ppmObs, checkPpm), bw = 1)$y
klDistance <- list()
subSamples <- ls()[grep("newDist",ls())]
for(j in seq_along(subSamples)) {
klDistance[[j]] <- suppressWarnings(entropy::KL.empirical(origDist,
get(subSamples[j])))
}
klDistance <- unlist(klDistance)
if(any(klDistance >= 0.5)) {
subsample <- F
} else {
checkPpm <- checkPpm/2
}
}
library(Autotuner)
