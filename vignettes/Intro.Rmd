---
title: "Intro to AutoTuner"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Intro}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(Autotuner)
library(devtools)
if(!require("mmetspData")) {
    install_github("crmclean/mmetspData")    
    library(mmetspData)
}
```

# Introduction

AutoTuner is a parameter tuning algorithm for XCMS, mzMine2, and other 
metabolomics data processing softwares. Using statistical inference, AutoTuner
quickly finds estimates for nine distinct parameters. This guide provides
an interactive example of how to use AutoTuner.

## Set up:

### Input - Raw Data

AutoTuner is designed to work directly with raw mass spectral data that has 
been processed by msconvert (). So far file types .mzML, .mzXML, .msData, and
.netCDF have been tested to work well. 

```{r loading mass spec data}
mmetspFiles <- c(system.file("mzMLs/mtab_mmetsp_ft_120815_24.mzML", package = "mmetspData"),
                 system.file("mzMLs/mtab_mmetsp_ft_120815_25.mzML", package = "mmetspData"),
                 system.file("mzMLs/mtab_mmetsp_ft_120815_26.mzML", package = "mmetspData"))
```
Here are the filetypes that will be used within this tutorial:
```{r filetype}
print(basename(mmetspFiles))
```

### Input - Metadata

AutoTuner also requires a metadata spreadsheet that has at least two columns 
in order to derive estimates. One column should contain string matches to all
the raw data files that will be processed. The second should contain information
on the experimental factor each sample belongs to. If you are using Shiny to 
run AutoTuner, the file have .csv formal. Future implementations of AutoTuner
will feature a broader suite of acceptable file types. 

```{r loading in metadata}
metadata <- read.csv(system.file("mmetsp_metadata.csv", package = "mmetspData"),
                    stringsAsFactors = F)

metadata <- metadata[metadata$File.Name %in% 
                         sub(pattern = ".mzML", "",basename(mmetspFiles)),]
```

This is what the metadata file should look like. In our case, the column 
matching the raw data files is called "File.Name", while the one with 
experimental factor information is called "Sample.Type".

```{r}
print(metadata)
```

## Setting up AutoTuner

### Creating AutoTuner Object

AutoTuner first requires that user create an AutoTuner object. All future
computations will be contained within the object. 

The file_col argument corresponds to the string column of the metadata that 
matches raw data samples by name. The factorCol argument corresponds to the 
specific factor column. 

```{r}
Autotuner <- createAutotuner(mmetspFiles,
                             metadata,
                             file_col = "File.Name",
                             factorCol = "Sample.Type")
```

### Sliding Window Analysis

Next comes the sliding window analysis. A sliding windown analysis is a simple
time series analysis tool used to identify peaks over a time trace. More on 
sliding window analyses can be found here: (wiki - sliding windown analysis)

This analysis is used here to subset the sample into regions that the algorithm 
assumes are enriched with a greater number of features. The only goal of this 
part of the algorithm is to find where peaks *start*. Downstream steps actually 
do a better job of estimating what the peaks bounds should be. 

The user should play with three parameters to accomplish this task:
lag - how big should the window be?
threshold - how many standard deviations above the standard deviation of the
window does a peak have to be to considered significant?
influence - If a peak is identified as significant, how much should its value 
contribute to the average value of the window?

```{r}
lag <- 30
threshold<- 3.5
influence <- 0.3
signals <- lapply(getAutoIntensity(Autotuner), 
                 ThresholdingAlgo, lag, threshold, influence)
```

The output of the sliding window can be displayed with the plot_signals
function:

```{r}
plot_signals(Autotuner, 
             threshold, 
             ## index for which data files should be displayed
             sample_index = 1:3, 
             signals = signals)
rm(lag, influence, threshold)
```

```{r}
Autotuner <- isolatePeaks(Autotuner, returned_peaks = 10, signals)
```

```{r}
for(i in unique(peak_difference$index)) {
    plot_peaks(Autotuner = Autotuner, 
           boundary = 100, 
           peak = i)    
}
```

```{r}
## error with peak width estimation
## idea - filter things by mass. smaler masses are more likely to be random assosications
eicParamEsts <- EICparams(Autotuner = Autotuner, 
                          massThresh = .005, 
                          verbose = F,
                          returnPpmPlots = F,
                          useGap = T)
```

```{r}
returnParams <- function(eicParamEsts, Autotuner) {
    
    params <- TIC_params(Autotuner@peak_table, Autotuner@peak_difference)
    
    colNameCheck <- all(c("ppm", "peakCount", 
                          "noiseThreshold", "prefilterI", 
                          "prefilterScan", 
      "TenPercentQuanSN","maxPw", "minPw") %in% colnames(eicParamEsts))
    
    assertthat::assert_that(colNameCheck, 
                            msg = "Error in EICparams: some of the column names from the output are missing. Cannot complete parameter estimation.")
    
    ppmEst <- weighted.mean(eicParamEsts$ppm, eicParamEsts$peakCount) 
    noiseEst <- min(eicParamEsts$noiseThreshold, na.rm = T)
    prefilterIEst <- min(eicParamEsts$prefilterI, na.rm = T)
    prefilterScanEst <- min(eicParamEsts$prefilterScan, na.rm = T)
    snEst <- min(eicParamEsts$TenPercentQuanSN, na.rm = T)
    
    maxPw <- split(eicParamEsts$maxPw, eicParamEsts$sampleID) 
    maxPw <- sapply(maxPw, max) 
    maxPw <- mean(maxPw) 
    
    minPw <- min(eicParamEsts$minPw)
    
    estimates <- c(ppm = ppmEst,
                   noise = noiseEst,
                   preIntensity = prefilterIEst,
                   preScan = prefilterScanEst,
                   snThresh = snEst,
                   "Max Peakwidth" = maxPw,
                   "Min Peakwidth" = minPw)
    
    rm(ppmEst,noiseEst,prefilterIEst,prefilterScanEst,snEst,maxPw,minPw)
    
    ppmSd <- sd(eicParamEsts$ppm)
    noiseSd <- sd(eicParamEsts$noiseThreshold)
    prefilSd <- sd(eicParamEsts$prefilterI, na.rm = T)
    prefilScanSd <- sd(eicParamEsts$prefilterScan, na.rm = T)
    snEstSd <- sd(eicParamEsts$TenPercentQuanSN, na.rm = T)
    maxPwDist <- abs(diff(sort(eicParamEsts$maxPw, decreasing = T))[1])
    minPwDist <- abs(diff(sort(eicParamEsts$minPw, decreasing = T))[2])
    
    variability <- c(ppmSd, noiseSd, prefilSd, prefilScanSd, snEstSd, 
                     maxPwDist, 
                     minPwDist)
    rm(ppmSd, noiseSd, prefilSd, prefilScanSd, snEstSd, maxPwDist, minPwDist)
    description <- c("Standard Deviation of all PPM Estimates",
                     "Standard Deviation of all noise Estimates",
                     'Standard Deviation of all prefileter Intensity Estimates',
                     "Standard Deviation of all scan coung Estimates",
                     "Standard Deviation of all s/n threshold Estimates",
                     "Distance between two highest estimated peak widths",
                     "Distance between two lowest estimated peak widths")
    
    
    aggregatedEstimates <- data.frame(Parameters = names(estimates),
                                      estimates = signif(estimates, 
                                                         digits = 4), 
                                      'Variability Measure' = signif(variability, 
                                                                     digits = 4), 
                                      "Measure" = description)
    return(aggregatedEstimates)
}
returnParams(eicParamEsts, Autotuner)
```


